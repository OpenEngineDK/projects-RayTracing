\chapter{KD-Trees}

%About KD-trees

\section{Creating KD-trees}


\begin{displaymath}
  SAH(x) = C_N + \frac{C_L(x) A_L(x)}{A} + \frac{C_R(x) A_R(x)}{A}
\end{displaymath}

where $C_N$ is the cose of traversing the node itself and is
independen of the splitting plane, $C_L{x}$ is the cost of traversing
the left child node given a split at $x$ and $C_R{x}$ is the cost of
traversing the right child node

\begin{displaymath}
  VVH(x) = C_N + \frac{C_L(x) V(d_L(x) \pm R)}{V(d \pm R)} +
  \frac{C_R(x) V(d_R(x) \pm R)}{V(d \pm R)}
\end{displaymath}

\section{Adopting the algorithm for GPGPUs}

% Needs to exploit the dataparallel nature of GPGPU's

% A GPGPU requires (more than) 10^3~10^4 threads for optimal
% performance. To hide latency from texture fetches? cite NVIDIA?

% At upper tree level nodes exploit data parallelism by parallising
% the cost computation over triangles or photons. 

% SAH assumes that each split results in 2 leaf nodes, which is
% practically always wrong at high level nodes, therefore
% \citealp{1409079} suggests splitting along the spatial median of the
% nodes longest axis. To do this a preprocess pass is required to
% compute tight AABB's for each triangle.

% Unlike \citealp{1409079} triangles will not be split in upper tree
% nodes. Instead two new bounding boxes (maybe triangles) will be
% created and updated to be inside the child nodes bounds. This is
% done to avoid creating extra triangles when splitting (1 triangle
% split often produces 3 triangles), which would result in deeper
% trees


% Creating the KD-tree in BFS will optimize GPU performance at lower
% tree levels, as there would be thousands of nodes created at the
% same time.

% At lower tree levels where SAH/VVH isn't computed parallel, perhaps
% and early out ``good enough'' value/ratio can be given, as done in
% BSP. Might only increase instructions, branching and still wait for
% the slowest thread. (Try and watch it fail)

\section{Raytracing KD-trees}

\section{Nearest neighbour search}
