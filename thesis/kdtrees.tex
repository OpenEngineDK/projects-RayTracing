\chapter{KD-Trees}

\chapterquote{In theory, there is no difference between theory and
  practice. But, in practice, there is.}{Jan L. A. van de Snepscheut}

% About KD-trees

\section{Motivation}

% Why KD tree compared to other structures

% Has time and time again been arguibly the best datastructure.

% Vlastimil Havran did an extensive study of available spatial
% subdivision schemes (including regular grids, nested grids, octrees
% and kd-trees) and concludes in his thesis that the kd-tree beats the
% other schemes in most cases. 

% Example of kd-tree flexibility over octree (important in sparse
% scenes / empty space partitioning)

% Cheap intersection / distance to tests. Havran p. 65


\section{Building KD-trees}

% Left blanced non pointer vs pointers

% Choose pointers as that would lead to less memory consumption and it
% places all nodes of the same level in a continues block, making it
% easier to work with them.

% Balanced trees suck, example of partition with high density in one
% side and no triangles in other side. Non balanced tree would leed to
% early exit.


\quotebook{Balancing is optimal only for binary searching, and if all
  nodes have equal access probabilities. Neither of these two
  prerequisites are fulfilled for range queries (such as ray traversal
  and kNN queries), nor for unevenly distributed primitives such as
  photons or triangles.}{wald:04:VVH}

% All the brilliance in KD-tree construction comes down to choosing
% the splitting plane and deciding when to stop.


\subsection{Splitting the geometry}

% Infinitely many splitting planes.

% Only interested in those finitely many planes where the resulting
% left and right voxel changes.


% Unlike \citebook{1409079} triangles will not be split in upper tree
% nodes. Instead two new bounding boxes (maybe triangles) will be
% created and updated to be inside the child nodes bounds. This is
% done to avoid creating extra triangles when splitting (1 triangle
% split often produces 3 triangles), which would result in deeper
% trees. 
% But this method requires us to test that an intersection is in fact
% inside the bb. Do we want that?


% Different splitting planes heuristics.


% When moving from upper nodes to lower nodes. Calculate a new tight
% bounding box inside the modified bounding box. Then approximate the
% new surface area by the reduction in BB volume.

% Instead of reordering geometry on each split (vertices, normals,
% colors, texcoords, whatnot), we instead simply move and index to the
% geometric primitive.

\subsubsection{Spatial median}

% Split at the spatial median.

% Refered to as the naive implementation in Wald07.

% Easy to understand, easy to implement and nice for getting things
% off the ground.

% Axis to split along can be choosen in a round robin fashion or the
% largest axis can be choosen. (Which initially minimises the surface
% of the children)

% Perform a check to reduce do empty space clipping and facilitate
% early out option for the rays. Requires ``magic splitting
% constants'', which can be very scene specific. (I haven't yet and
% it's not easy!)


\subsubsection{Surface Area Heuristic}

% SAH assumptions can be seen in Wald07

% Globlly optimal is infeasable for complex scenes and instead a local
% greedy approximation is used.

\begin{displaymath}
  SAH(N \rightarrow \{L, R\}) = C_N + \frac{C_L A_L}{A_N} +
  \frac{C_R A_R}{A_N}
\end{displaymath}

where $C_N$ is the cost of traversing the node itself and is
independent of the splitting plane, $C_L$ is the cost of traversing
the left child nodeand $C_R$ is the cost of traversing the right child
node

% SAH assumes that each split results in 2 leaf nodes, which is
% practically always wrong at high level nodes, therefore
% \citebook{1409079} suggests splitting along the spatial median of the
% nodes longest axis. To do this a preprocess pass is required to
% compute tight AABB's for each triangle.

% SAH yields the best trees.

% SAH calculation optimizations include axis round robin and some damn
% paper I can't remember.

\subsubsection{Empty Space Splitting}

\subsubsection{Splitting or Dividing Geometry}

% What to do with the triangles caught in the splitting plane.

% Normally ppl split.

% Novel scheme? Dvide triangles eg. adjust bounding box instead of
% splitting the triangles.

% Spliting will almost always produce 3 triangles, whereas divide will
% always produce only 2.

% Adjusting area heuristic, computes the largest plane possible in the
% bounding boxes and compares them. An optimization could be
% precomputing the plane while gathering geometry.

% In conclussion:

% Profile the time it takes to create the different trees, especially
% the splitting kernels.

% Compare amount of nodes.

% Tree traversal time.


\subsection{Algorithm for creating KD-tree}

% Argue it can be done in O ( N log N )



\section{Adopting the algorithms for GPGPUs}

% Needs to exploit the dataparallel nature of GPGPU's

% A GPGPU requires (more than) 10^3~10^4 threads for optimal
% performance. To hide latency from texture fetches? cite NVIDIA?

% Use GPU for computations and let CPU handle minor book keeping.

% Handles structures of arrays better than arrays of structures
% chapter 33 \citebook{GPUGEMS2} and coalescence

\subsection{Upper Tree Nodes}

% At upper tree level nodes exploit data parallelism by parallising
% the cost computation over triangles. 

% Use spatiel median splitting for upper nodes. Way faster than SAH
% calculations.

% Creating the KD-tree in BFS will optimize GPU performance at lower
% tree levels, as there would be thousands of nodes created at the
% same time.

\subsubsection{Empty space splitting}

\begin{itemize}
  \item Store the post split aabb as the child nodes aabb. (uh even
    upper leafs get an aabb now)
  \item When reducing the correct aabb, compare it to the old one
    before overwriting and store splitting sides in a char bitmap and counter var (for cudpp scan).
  \item When creating children take empty space into account.
  \item | LEAFS | EMPTY SPACE NODES | PROCESSABLE NODES |
  \item Ray tracing profit.
\end{itemize}

\subsection{Lower Tree Nodes}

% At lower tree levels where SAH/VVH isn't computed parallel, perhaps
% and early out ``good enough'' value/ratio can be given, as done in
% BSP. Might only increase instructions, branching and still wait for
% the slowest thread. (Try and watch it fail) Perhaps without an if
% statement but by arithmetic instead?

% Try persistent threads method!



%% \subsection{Photon Map}

%% \begin{algorithm}
%%   \caption{Photon KD-Tree upper node handling}
%%   \label{alg:PhotonUpperNode}
%%   \begin{algorithmic}
%%     \PROCEDURE{CreateUpperPhotonNodes}
%%               {\VAR{activeList}:list \textit{list of kd-nodes not processed yet}}
%%               {\VAR{lowerList,nextList}:list}{
%%       \STATE{Check size of upper nodes arrays and allocate more if needed.}

%%       \COMMENTIT{Compute bounding box of all active nodes.}
%%       \PARALLELFOR{active node}
%%       \STATE{Compute the bounding box off all it's photons.}
%%       \ENDFOR

%%       \PARALLELFOR{active node}
%%       \STATE{Insert split position, axis and child index}
%%       \ENDFOR

%%       \COMMENTIT{Split photons along axis and store the split index in
%%         the child node}
%%       \FOR{active node}
%%       \STATE{Split the photons in the node \textbf{in parallel}} % Using scan primitives from Sengupta
%%       \ENDFOR

%%       \PARALLELFOR{new node}
%%       \STATE{Split into nextnodes and lowernodes.}
%%       \STATE{Setup links from parents to childrens new position.}
%%       \ENDFOR

%%       \COMMENTIT{CPU bookkeeping}
%%       \COMMENTIT{Perhaps this can be done in a kernel aswell, no need
%%         to do more on the cpu then absolutely necessary.}
%%       \STATE{Copy small child nodes to lowerList}
%%     }
%%   \end{algorithmic}
%% \end{algorithm}


%% \begin{algorithm}
%%   \caption{Lower node handling of the photon kd-tree}
%%   \label{alg:PhotonLowerNode}
%%   \begin{algorithmic}
%%     \PROCEDURE{CreateLowerPhotonNodes}
%%               {\VAR{activeList}:list}
%%               {\VAR{nextList}:list}{
%%                 \PARALLELFOR{node \VAR{i} \textbf{in} activeList}
%%                 \COMMENTIT{Determine optimal splitting plane}
                
%%                 \ASSIGN{\VAR{root}}{\VAR{i.smallRoot}}
%%                 \ASSIGN{\VAR{VVH_0}}{$\|$ \VAR{i.photonBitmap} $\|$}
%%                 \ASSIGN{$VVH$}{$\infty$}
%%                 \STATE{$splitCandidate$}

%%                 \FOR{\textbf{each} splitplane \VAR{s} where s.triangle $\in$ i.photonBitmap}
%%                   \ASSIGN{\VAR{C_L}}{$\| i.triangleSet \cap s.left \|$}
%%                   \ASSIGN{\VAR{C_R}}{$\| i.triangleSet \cap s.right \|$}
%%                   \COMMENTIT{Can't precompute the max and min in splitplane, since triangles change}
%%                   \ASSIGN{$V_L$}{$\sum^k s.max.k - s.min.k + 2 * R$}
%%                   \ASSIGN{$V_L$}{$\sum^k s.max.k - s.min.k + 2 * R$}
%%                   \ASSIGN{$VVH_s$}{$C_L * V_L + C_R * V_R$}
%%                   \IF{$VVH_S < VVH_S$}
%%                     \ASSIGN{$VVH$}{$VVH_S$}
%%                     \ASSIGN{$splitCandidate$}{$s$}
%%                   \ENDIF
%%                 \ENDFOR

%%                 \COMMENTIT{Split to new nodes (Perhaps move this to
%%                   another kernel after doing a scan to determine where
%%                   to place new nodes? Hmm?}

%%                 \ENDFOR
%%               }
%%   \end{algorithmic}
%% \end{algorithm}
