\chapter{KD-Trees}\label{chp:kdTrees}

\chapterquote{In theory, there is no difference between theory and
  practice. But, in practice, there is.}{Jan L. A. van de Snepscheut}


% About KD-trees

Before we in \refchapter{chp:rayTracing} discuss how the rays will
traverse the hierarchical acceleration structure, we must first
examine their structure.

% Why KD tree compared to other structures

As explained earlier in this thesis, I will be using kd-trees to
accelerate ray tracing. This choice is based on several factors. 

% Cheap intersection / distance to tests. Havran p. 51

One of them is the ease with which the signed distance from a ray to a
kd-trees axis aligned splitting plane can be computed. The splitting
plane can be described by an axis, $d \in \{x, y, z\}$, and it's
position along that axis, $N_d$. The signed distance from any ray,
$R(t) = O + tD$, to the splitting plane is then simply calculated as

\begin{displaymath}
  t = \frac{N_d - O_d}{D_d}
\end{displaymath}

For comparison a generel \textit{binary space partition} tree,
\textit{BSP} tree, with arbitrarily oriented splitting planes, given
by $ax + by + cz + d = 0$ has a much more complex distance function.

\begin{displaymath}
  t = \frac{a O_x + b O_y + c O_z + d}{a D_x + b D_y + c D_z}
\end{displaymath}

It becomes even more complex when bounding volumes are used. An axis
aligned bounding box can be described by 2 points, $V_{min}$ and
$V_{max}$. Calculating the signed distance to any rays entry and exit
point is then

\begin{displaymath}
  \begin{array}{l}
    t_{near,d} = min((V_{min,d} - O_d) / D_d, (V_{max,d} - O_d) / D_d)\\
    t_{entry} = max(t_{near,x}, t_{near,y}, t_{near,z})
  \end{array}
\end{displaymath}

The distance from the ray origin to all of the bounding box sides are
calculated, then the minimum along each axis is chosen and the maximum
of these values are the distance to the entry point. The distance to
the exit point is calculated similarly.

\begin{displaymath}
  \begin{array}{l}
    t_{far,d} = max((V_{min,d} - O_d) / D_d, (V_{max,d} - O_d) / D_d)\\
    t_{entry} = min(t_{far,x}, t_{far,y}, t_{far,z})
  \end{array}
\end{displaymath}


If the rays exit distance lies closer than the entry distance, then
the ray did not intersect the bounding volume, an example of this is
given on \reffig{fig:rayBoxIntersection}.

\begin{figure}
  \centering
  \includegraphics[width=5cm]{RayBoxIntersection}
  \caption{Ray/Box intersection.}
%TODO image curtesy of http://www.baylee-online.net/Projects/Raytracing/RT4
  \label{fig:rayBoxIntersection}
\end{figure}

Clearly kd-trees provide the simplest distance calculations of the
above given examples.

% Example of kd-tree flexibility over octree (important in sparse
% scenes / empty space partitioning)

Binary trees, such as kd- and bsp trees, are also more flexible than
quadtress or octrees. An example can be seen on
\reffig{fig:binQuadSplit}. This flexibility can be extremely important
when accelerating sparse scenes.

\begin{figure}
  \centering
  \subfloat[Possible binary splits.]{
    \begin{tikzpicture}[y=0.5cm, x=.5cm,font=\sffamily]
      
      % AABB
      \draw (0,0) -- (6,0) -- (6,4) -- (0,4) -- (0,0);
      
      % TRIS
      \draw (0,4) -- (3, 3) -- (1.5,1) -- (0,4);
      \draw (6,1) -- (4, 2) -- (4,0) -- (6,1);
      
      % splits
      \draw[color=green] (3,0) -- (3,4);
      \draw[color=green] (0,1) -- (3,1);
      \draw[color=green] (3,2) -- (6,2);
      
    \end{tikzpicture}
    \label{fig:binarySplit}
  }
  \subfloat[Possible quadternary splits.]{
    \begin{tikzpicture}[y=0.5cm, x=.5cm,font=\sffamily]
      
      % AABB
      \draw (0,0) -- (6,0) -- (6,4) -- (0,4) -- (0,0);
      
      % TRIS
      \draw (0,4) -- (3, 3) -- (1.5,1) -- (0,4);
      \draw (6,1) -- (4, 2) -- (4,0) -- (6,1);
      
      % splits
      \draw[color=red] (3,0) -- (3,4);
      \draw[color=red] (0,1) -- (6,1);
      
    \end{tikzpicture}
    \label{fig:quadternarySplit}
  }
  \caption{A comparisson of binary and quadternary splitting. Notice
    that the binary splitting planes can be placed without
    intersecting any geometry.}
  \label{fig:binQuadSplit}
\end{figure}


%% \begin{figure}
%%   \subfloat[binary]{
%%     \begin{tikzpicture}[y=0.5cm, x=.5cm,font=\sffamily]
%%       \draw (0,0) -- coordinate (x axis mid) (6,0);
%%     \end{tikzpicture}
%%     \caption{binary.}
%%     \label{fig:binarySplit}
%%   }

%%   %% \subfloat[quad]{
%%   %%   \begin{tikzpicture}[y=0.5cm, x=.5cm,font=\sffamily]
%%   %%   \end{tikzpicture}
%%   %%   \label{fig:quadSplit}
%%   %% }

%%   \caption{A comparison of binary trees and quad trees.}
%%   \label{fig:binaryVsQuad}
%% \end{figure}

% Vlastimil Havran did an extensive study of available spatial
% subdivision schemes (including regular grids, nested grids, octrees
% and kd-trees) and concludes in his phd thesis that kd-trees are
% better than the other schemes in most cases.

Finally, in his phd. dissertation, Vlastimil Havran did an extensive
study of spatial data structures, including grids, octress and
kd-trees, and found that the kd-tree performed the best in most cases.

Given all of the above and with the recent paper by \zhou, in which
kd-trees are constructed in real-time on graphics hardware, it is easy
to see why the choice fell on kd-trees as the acceleration structure.

% About this Chapter. Start by motivation. Then explain how kd-trees
% are constructed, including different strategies for choosing the
% spliting plane and doing the actual geometry splitting. Then the
% chapter will end with a discussion of how to implement the
% algorithms efficiently on a SIMT architecture.

In the rest of this chapter, we will first examine how kd-trees are
built. In particular we will be studying different algorithms for
choosing the splitting plane candidate and how to handle geometry
intersecting the splitting plane. The latter part of this chapter
deals with converting a sequential kd-tree construction algorithm into
a dataparallel algorithm. Focus is split between upper tree nodes and
lower tree nodes, once the number of geometric primitives per node
goes below a certain threshold.

\section{Building KD-trees}

A kd-tree is a binary tree that recursively subdivides geometry into
smaller tree nodes. \refalg{alg:kdTreeCreator} describes a generel
recursive kd-tree construction scheme.

\begin{algorithm}
  \caption{Recursive kd-tree constructor}
  \label{alg:kdTreeCreator}
  \begin{algorithmic}
    \PROCEDURE{ConstructKDTree}
              {$T$ : Triangle List; $voxel$ : AABB}
              {$node$ : KDNode}
              {\IF{IsLeaf($T, voxel$)}
                  \ASSIGN{$node$}{Leaf(T)}
                \ELSE
                  \COMMENTIT{Determining the splitting plane will be discussed in \refsection{sec:splittingPlane}}
                  \ASSIGN{$plane$}{DeterminePlane($T, voxel$)}
                  \ASSIGN{$(voxel_L, voxel_R)$}{Split($voxel, p$)}
                  \COMMENTIT{How to associate geometry with a voxel will be the topic of  \refsection{sec:splittingGeom}}
                  \ASSIGN{$T_L$}{AssociateGeometry($T, voxel_L$)}
                  \ASSIGN{$T_R$}{AssociateGeometry($T, voxel_R$)}
                  \ASSIGN{$node$}{Node($plane$, ConstructKDTree($T_L, voxel_L$), ConstructKDTree($T_R, voxel_R$))}
                \ENDIF}
  \end{algorithmic}
\end{algorithm}

ConstructKDTree takes as arguments a list of triangles and an axis
aligned bounding box defining the volume of the node. The algorithm
then checks if the triangles and bounding box satisfy the requirements
of beeing a leaf node. If so, then a leaf is produced and the
recursion terminates. If not then a splitting plane, $plane$, needs to
be determined and the bounding box is divided by $plane$, producing a
new left and right axis aligned bounding box. Triangles are then
distributed to each new bounding box by some decision algorithm and a
new node is created that will contain references to it's 2 children.

% Left balanced non pointer vs pointers

In generel there are 2 ways a node can reference its child nodes. The
first is \textit{balanced trees}, where children of a node can be
addressed implicitly without the use of pointers. The reason for this
is that nodes at teh same tree level are placed sequantially in
memory. The left and right child of node $n$ can then be indexed using
$2n+1$ and $2n+2$. The parent of a node is indexed with $\lceil n/2
\rceil - 1$.

% Balanced trees suck, example of partition with high density in one
% side and no triangles in other side. 

Wald et al.\citebook{wald:04:VVH} has the following to say about
balanced trees.

\quotebook{Balancing is optimal only for binary searching, and if all
  nodes have equal access probabilities. Neither of these two
  prerequisites are fulfilled for range queries (such as ray traversal
  and kNN queries), nor for unevenly distributed primitives such as
  photons or triangles.}{wald:04:VVH}

% Choose pointers as that would lead to less memory consumption and it
% places all nodes of the same level in a continues block, making it
% easier to work with them.

To avoid balanced trees we can instead use pointers to reference the
children. This allows for more flexibility when creating the tree.
Unfortunatly it also means storing more data per node and in the case
of slow memory access it could cause a memory latency
bottleneck. However, in a survay of different techniques such as this,
the added flexibility can be a benefit and in
\refsection{sec:gpuEmptySpace} we shall see how this flexibility can
be used to add empty space splitting, something that could not have
been done as unobtrusive had the tree been balanced.




\subsection{Choosing the Splitting Plane}\label{sec:splittingPlane}

% All the brilliance in KD-tree construction comes down to choosing
% the splitting plane and deciding when to stop.

Looking again at \refalg{alg:kdTreeCreator}, we can see that all the
brilliance in constructing a high quality kd-tree is knowing where to
place the splitting plane and when to end the recursion and create a
leaf.

% Different splitting planes heuristics.

In the following section 2 algorithms that solves this problem is
presented and then extended with empty space splitting.


\subsubsection{Spatial median}

% Split at the spatial median.

% Axis to split along can be choosen in a round robin fashion or the
% largest axis can be choosen. (Which initially minimises the surface
% of the children)

A quite simple method of choosing the splitting plane is to place it
at the spatial median of the nodes bounding box. There are 2 ways to
choose which dimensional spatial median to use. A \textit{round robin}
fashion can be used, where the dimensions are cycled every iteration;
ie. when creating the first node the plane will lie perpendicular to
the x-axis, the children will then be split along the y-axis, in the
next iteration the plane will split along the z-axis and so
on. Another way of choosing the dimension is to split along the nodes
bounding box' largest axis. This can be more costly than the round
robin approach, since the entire bounding box will have to be
calculated each iteration, but it will also produce the best results.

The termination requirement for spatial median splitting is equally
simple as choosing the splitting plane. If the number of triangles per
node falls below a certain threshold, iteration stops.

% Refered to as the naive implementation in Wald07.

This method is refered to as naïve in \citebook{wald:06:NlogN} and
rightly so. Not much thought is put into the distribution of geometry
inside the bounding box. On \reffig{crapMedian} an example is given
where the node is split in a non-intuitive way. Spatial median
splitting does, however, make up for its suboptimal splitting planes
by being quite fast, and I will therefore use it for creating my
kd-trees upper nodes, as is described in \section{sec:upperNodes}.

\begin{figure}
  \centering
  \begin{tikzpicture}[y=0.5cm, x=.5cm,font=\sffamily]
    % AABB
    \draw (0,0) -- (6,0) -- (6,4) -- (0,4) -- (0,0);

    % Tris
    \draw (0,0) -- (2,4) -- (4,0) -- (0,0);
    \draw (5,4) -- (5.5,4) -- (5,3) -- (5,4);
    \draw (5,2.5) -- (5.5,2.5) -- (5.5,3.5) -- (5,2.5);
    \draw (5,2) -- (6,2) -- (5.5,0.5) -- (5,2);

    % Split
    \draw[color=red] (3,0) -- (3,4);
    \draw[color=green] (5,0) -- (5,4);

  \end{tikzpicture}
  \caption{An example of how median splitting produces poor
    splits. The red line is a median split. The green line is a more
    optimal splitting plane, since it divides the large triangle from
    the small.}
  \label{fig:crapMedian}
\end{figure}

\subsubsection{Surface Area Heuristic}

% SAH assumptions can be seen in Wald07

% Globlly optimal is infeasable for complex scenes and instead a local
% greedy approximation is used.

\begin{displaymath}
  SAH(N \rightarrow \{L, R\}) = C_N + \frac{C_L A_L}{A_N} +
  \frac{C_R A_R}{A_N}
\end{displaymath}

where $C_N$ is the cost of traversing the node itself and is
independent of the splitting plane, $C_L$ is the cost of traversing
the left child nodeand $C_R$ is the cost of traversing the right child
node

% SAH assumes that each split results in 2 leaf nodes, which is
% practically always wrong at high level nodes, therefore
% \citebook{1409079} suggests splitting along the spatial median of the
% nodes longest axis. To do this a preprocess pass is required to
% compute tight AABB's for each triangle.

% SAH yields the best trees.

% SAH calculation optimizations include axis round robin and some damn
% paper I can't remember.

\paragraph{Splitting Planes}

% To avoid having to test the infinitely many splitting planes
% possible, we instead have to choose sensible planes for SAH.

% Infinitely many splitting planes.

% Discuss perfect splits?

% Only interested in those finitely many planes where the resulting
% left and right voxel changes.

% The sides of the triangles are an obvious choice, however
% precalculating these leads to incorrectly sorting triangles into
% nodes that the triangles do not intersect. (Example of a bounding box
% being inside a node, when the actual triangle is outside)

% A solution is to continuously adjust the bounding box of the split
% goemetry, creating 'perfect split' condidates.

% Another is to simply remove the offending triangles, reafter refered
% to as \textit{false primitives}, from the nodes by a triangle/box
% intersection test during or after creation.

% When moving from upper nodes to lower nodes. Calculate a new tight
% bounding box inside the modified bounding box. Then approximate the
% new surface area by the reduction in BB volume.


\subsubsection{Empty Space Splitting}

% Dynamic empty space threshold, favor early out in the top of the tree.

% huge ray tracing performance improvement in testscene (23% without
% raytracers doing intersection tests at leaf nodes)

% Implementation is 

\subsection{Splitting the Geometry}\label{sec:splittingGeom}

This section will look at alternatives to triangle splitting, namely
\textit{triangle division}, where the triangle is not split by
splitting planes, but divided onto each side, by simply adjusting it's
bounding box, and \textit{box inclusion}, where the triangles
themselves are not tested for inclusion, but their bounding boxes are.

% What to do with the triangles caught in the splitting plane.



\subsubsection{Splitting Triangles}

% Normally ppl split.

\subsubsection{Dividing Triangles}

% Novel scheme? Dvide triangles eg. adjust bounding box instead of
% splitting the triangles.

% Spliting will almost always produce 3 triangles, whereas divide will
% always produce only 2.

% Adjusting area heuristic: When we no longer split geometry, SAH
% becomes an even worse approximation. This can be fixed by an
% adjusting area heuristic, where the diagonal of the geometric
% primitives original bounding box is compared to the diagonal of the
% reduced box and the primitives surface area is adjusted accordingly.


\subsubsection{Adjusting Bounding Boxes}

% Simpler than splitting.

% Inspired by the small node step in Zhou

% Naturally increases amount of \textit{false primitives} in the tree, but is
% very cheap.

% Also has an increased change of looping during construction in
% combination with a small max lower size. Fx fairy forest loops using
% adjusting bounding box with a max size of 32 primtives in leaf nodes.

% False primitives can then be removed at a later stage at the cost of
% some extra overhead. Or combine with Divide every n'th step for
% optimal sweetness.

% With the added leaf intersection in the raytracer, extra triangles
% in the leaf nodes become even less important and this method starts
% to shine for dynamic scenes.


% In conclussion:

% Profile the time it takes to create the different trees, especially
% the splitting kernels.

% Compare amount of nodes.

% Tree traversal time.




\section{Adopting the algorithms for GPGPUs}

% Needs to exploit the dataparallel nature of GPGPU's

% A GPGPU requires (more than) 10^3~10^4 threads for optimal
% performance. To hide latency from texture fetches? cite NVIDIA?

% Use GPU for computations and let CPU handle minor book keeping.

% Handles structures of arrays better than arrays of structures
% chapter 33 \citebook{GPUGEMS2} and coalescence

\subsection{Upper Tree Nodes}\label{sec:upperNodes}

% At upper tree level nodes exploit data parallelism by parallising
% the cost computation over triangles. 

% Use spatiel median splitting for upper nodes. Way faster than SAH
% calculations.

% Creating the KD-tree in BFS will optimize GPU performance at lower
% tree levels, as there would be thousands of nodes created at the
% same time.

% Instead of reducing the sizes of child nodes, I propose a method for
% calculating them directly. This leads to lots of uncoalesced
% lookups, so argue if the GPU is able to properly hide these.

% Building the upper nodes mostly consist of moving data around, and
% not necessarily in a coalesced fashion. This makes it hard to hide
% the latency and will impact performance.

% Argue it can be done in O ( N log N )

\subsubsection{Empty space splitting}\label{sec:gpuEmptySpace}

% Plugable solution, add the new nodes after the ones in nextlist.

% Propagating aabb's downwards

% A good threshold. Did I make it vary and how did that go?

% Perhaps it can be started in it's own stream? At least the actual
% empty space splitting should be able to. Could help out at the early
% tree creation when the GPU is underutilized. Suggest or actually
% try? Would make it an even cheaper optimization.

\subsection{Lower Tree Nodes}

% At lower tree levels where SAH isn't computed parallel, perhaps and
% early out ``good enough'' value/ratio can be given, as done in
% BSP. Might only increase instructions, branching and still wait for
% the slowest thread. (Try and watch it fail) Perhaps without an if
% statement but by arithmetic instead?

% Try persistent threads method!



%% \subsection{Photon Map}

%% \begin{algorithm}
%%   \caption{Photon KD-Tree upper node handling}
%%   \label{alg:PhotonUpperNode}
%%   \begin{algorithmic}
%%     \PROCEDURE{CreateUpperPhotonNodes}
%%               {\VAR{activeList}:list \textit{list of kd-nodes not processed yet}}
%%               {\VAR{lowerList,nextList}:list}{
%%       \STATE{Check size of upper nodes arrays and allocate more if needed.}

%%       \COMMENTIT{Compute bounding box of all active nodes.}
%%       \PARALLELFOR{active node}
%%       \STATE{Compute the bounding box off all it's photons.}
%%       \ENDFOR

%%       \PARALLELFOR{active node}
%%       \STATE{Insert split position, axis and child index}
%%       \ENDFOR

%%       \COMMENTIT{Split photons along axis and store the split index in
%%         the child node}
%%       \FOR{active node}
%%       \STATE{Split the photons in the node \textbf{in parallel}} % Using scan primitives from Sengupta
%%       \ENDFOR

%%       \PARALLELFOR{new node}
%%       \STATE{Split into nextnodes and lowernodes.}
%%       \STATE{Setup links from parents to childrens new position.}
%%       \ENDFOR

%%       \COMMENTIT{CPU bookkeeping}
%%       \COMMENTIT{Perhaps this can be done in a kernel aswell, no need
%%         to do more on the cpu then absolutely necessary.}
%%       \STATE{Copy small child nodes to lowerList}
%%     }
%%   \end{algorithmic}
%% \end{algorithm}


%% \begin{algorithm}
%%   \caption{Lower node handling of the photon kd-tree}
%%   \label{alg:PhotonLowerNode}
%%   \begin{algorithmic}
%%     \PROCEDURE{CreateLowerPhotonNodes}
%%               {\VAR{activeList}:list}
%%               {\VAR{nextList}:list}{
%%                 \PARALLELFOR{node \VAR{i} \textbf{in} activeList}
%%                 \COMMENTIT{Determine optimal splitting plane}
                
%%                 \ASSIGN{\VAR{root}}{\VAR{i.smallRoot}}
%%                 \ASSIGN{\VAR{VVH_0}}{$\|$ \VAR{i.photonBitmap} $\|$}
%%                 \ASSIGN{$VVH$}{$\infty$}
%%                 \STATE{$splitCandidate$}

%%                 \FOR{\textbf{each} splitplane \VAR{s} where s.triangle $\in$ i.photonBitmap}
%%                   \ASSIGN{\VAR{C_L}}{$\| i.triangleSet \cap s.left \|$}
%%                   \ASSIGN{\VAR{C_R}}{$\| i.triangleSet \cap s.right \|$}
%%                   \COMMENTIT{Can't precompute the max and min in splitplane, since triangles change}
%%                   \ASSIGN{$V_L$}{$\sum^k s.max.k - s.min.k + 2 * R$}
%%                   \ASSIGN{$V_L$}{$\sum^k s.max.k - s.min.k + 2 * R$}
%%                   \ASSIGN{$VVH_s$}{$C_L * V_L + C_R * V_R$}
%%                   \IF{$VVH_S < VVH_S$}
%%                     \ASSIGN{$VVH$}{$VVH_S$}
%%                     \ASSIGN{$splitCandidate$}{$s$}
%%                   \ENDIF
%%                 \ENDFOR

%%                 \COMMENTIT{Split to new nodes (Perhaps move this to
%%                   another kernel after doing a scan to determine where
%%                   to place new nodes? Hmm?}

%%                 \ENDFOR
%%               }
%%   \end{algorithmic}
%% \end{algorithm}
