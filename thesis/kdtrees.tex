\chapter{KD-Trees}\label{chp:kdTrees}

\chapterquote{In theory, there is no difference between theory and
  practice. But, in practice, there is.}{Jan L. A. van de Snepscheut}


% About KD-trees

Before we in \refchapter{chp:rayTracing} discuss how the rays will
traverse the hierarchical acceleration structure, we must first
examine their structure.

% Why KD tree compared to other structures

As explained earlier in this thesis, I will be using kd-trees to
accelerate ray tracing. This choice is based on several factors. 

% Cheap intersection / distance to tests. Havran p. 51

One of them is the ease with which the signed distance from a ray to a
kd-trees axis aligned splitting plane can be computed. The splitting
plane can be described by an axis, $d \in \{x, y, z\}$, and it's
position along that axis, $N_d$. The signed distance from any ray,
$R(t) = O + tD$, to the splitting plane is then simply calculated as

\begin{displaymath}
  t = \frac{N_d - O_d}{D_d}
\end{displaymath}

%% One of the reasons that the kd-tree, with it's axis aligned
%% splitting planes, is faster to traverse than a general
%% \textit{binary space partition} tree, \textit{BSP} tree, with
%% arbitrarily oriented splitting planes.

For comparison a generel \textit{binary space partition} tree,
\textit{BSP} tree, with arbitrarily oriented splitting planes, given
by $ax + by + cz + d = 0$ has a much more complex distance function.

\begin{displaymath}
  t = \frac{a O_x + b O_y + c O_z + d}{a D_x + b D_y + c D_z}
\end{displaymath}

It becomes even more complex when bounding volumes are used. An axis
aligned bounding box can be described by 2 points, $V_{min}$ and
$V_{max}$. Calculating the signed distance to any rays entry and exit
point is then

\begin{displaymath}
  \begin{array}{l}
    t_{near,d} = min((V_{min,d} - O_d) / D_d, (V_{max,d} - O_d) / D_d)\\
    t_{entry} = max(t_{near,x}, t_{near,y}, t_{near,z})
  \end{array}
\end{displaymath}

The distance from the ray origin to all of the bounding box sides are
calculated, then the minimum along each axis is chosen and the maximum
of these values are the distance to the entry point. The distance to
the exit point is calculated similarly.

\begin{displaymath}
  \begin{array}{l}
    t_{far,d} = max((V_{min,d} - O_d) / D_d, (V_{max,d} - O_d) / D_d)\\
    t_{entry} = min(t_{far,x}, t_{far,y}, t_{far,z})
  \end{array}
\end{displaymath}


If the rays exit distance lies closer than the entry distance, then
the ray did not intersect the bounding volume, an example of this is
given on \reffig{fig:rayBoxIntersection}.

\begin{figure}
  \centering
  \includegraphics[width=5cm]{RayBoxIntersection}
  \caption{Ray/Box intersection.}
%TODO image curtesy of http://www.baylee-online.net/Projects/Raytracing/RT4
  \label{fig:rayBoxIntersection}
\end{figure}

Clearly kd-trees provide the simplest distance calculations of the
above given examples.

% Example of kd-tree flexibility over octree (important in sparse
% scenes / empty space partitioning)

Binary trees, such as kd- and bsp trees, are also more flexible than
quadtress or octrees. An example can be seen on \reffig{TODO}. This
flexibility can be extremely important when accelerating sparse
scenes.

% Vlastimil Havran did an extensive study of available spatial
% subdivision schemes (including regular grids, nested grids, octrees
% and kd-trees) and concludes in his phd thesis that kd-trees are
% better than the other schemes in most cases.

Finally, in his phd dissertation, Vlastimil Havran did an extensive
study of spatial data structures, including grids, octress and
kd-trees, and found that the kd-tree performed the best in most cases.

Given all of the above and with the recent paper by \zhou, in which
kd-trees are constructed in real-time on graphics hardware, it is easy
to see why the choice fell on kd-trees as the acceleration structure.

% About this Chapter. Start by motivation. Then explain how kd-trees
% are constructed, including different strategies for choosing the
% spliting plane and doing the actual geometry splitting. Then the
% chapter will end with a discussion of how to implement the
% algorithms efficiently on a SIMT architecture.

In the rest of this chapter, we will first examine how kd-trees are
built. In particular we will be studying different algorithms for
choosing the splitting plane candidate and how to handle geometry
intersecting the splitting plane. The latter part of this chapter
deals with converting a sequential kd-tree construction algorithm into
a dataparallel algorithm. Focus is split between upper tree nodes and
lower tree nodes, once the number of geometric primitives per node
goes below a certain threshold.

\section{Building KD-trees}

% Left balanced non pointer vs pointers

% Choose pointers as that would lead to less memory consumption and it
% places all nodes of the same level in a continues block, making it
% easier to work with them.

% Balanced trees suck, example of partition with high density in one
% side and no triangles in other side. Non balanced tree would leed to
% early exit.

\quotebook{Balancing is optimal only for binary searching, and if all
  nodes have equal access probabilities. Neither of these two
  prerequisites are fulfilled for range queries (such as ray traversal
  and kNN queries), nor for unevenly distributed primitives such as
  photons or triangles.}{wald:04:VVH}


% \subsection{Algorithm for creating KD-tree}

% All the brilliance in KD-tree construction comes down to choosing
% the splitting plane and deciding when to stop.

% Argue it can be done in O ( N log N )



\subsection{Choosing the Splitting Plane}\label{sec:splittingPlane}

% Infinitely many splitting planes.

% Only interested in those finitely many planes where the resulting
% left and right voxel changes.

% Different splitting planes heuristics.

% Instead of reordering geometry on each split (vertices, normals,
% colors, texcoords, whatnot), we instead simply move an index to the
% geometric primitive. Also decouples the KD-tree creation from the
% geometry attributes and shading.



\subsubsection{Spatial median}

% Split at the spatial median.

% Refered to as the naive implementation in Wald07.

% Easy to understand, easy to implement and nice for getting things
% off the ground.

% Axis to split along can be choosen in a round robin fashion or the
% largest axis can be choosen. (Which initially minimises the surface
% of the children)

% Perform a check to reduce do empty space clipping and facilitate
% early out option for the rays. Requires ``magic splitting
% constants'', which can be very scene specific.


\subsubsection{Surface Area Heuristic}

% SAH assumptions can be seen in Wald07

% Globlly optimal is infeasable for complex scenes and instead a local
% greedy approximation is used.

\begin{displaymath}
  SAH(N \rightarrow \{L, R\}) = C_N + \frac{C_L A_L}{A_N} +
  \frac{C_R A_R}{A_N}
\end{displaymath}

where $C_N$ is the cost of traversing the node itself and is
independent of the splitting plane, $C_L$ is the cost of traversing
the left child nodeand $C_R$ is the cost of traversing the right child
node

% SAH assumes that each split results in 2 leaf nodes, which is
% practically always wrong at high level nodes, therefore
% \citebook{1409079} suggests splitting along the spatial median of the
% nodes longest axis. To do this a preprocess pass is required to
% compute tight AABB's for each triangle.

% SAH yields the best trees.

% SAH calculation optimizations include axis round robin and some damn
% paper I can't remember.

% To avoid having to test the infinitely many splitting planes
% possible, we instead have to choose sensible planes for SAH.

% The sides of the triangles are an obvious choice, however
% precalculating these leads to incorrectly sorting triangles into
% nodes that the triangles do not intersect. (Example of a bounding box
% being inside a node, when the actual triangle is outside)

% A solution is to continuously adjust the bounding box of the split
% goemetry, creating 'perfect split' condidates.

% Another is to simply remove the offending triangles, reafter refered
% to as \textit{false primitives}, from the nodes by a triangle/box
% intersection test during or after creation.

% When moving from upper nodes to lower nodes. Calculate a new tight
% bounding box inside the modified bounding box. Then approximate the
% new surface area by the reduction in BB volume.


\subsubsection{Empty Space Splitting}

% Dynamic empty space threshold, favor early out in the top of the tree.

% huge ray tracing performance improvement in testscene (23% without
% raytracers doing intersection tests at leaf nodes)

% Implementation is 

\subsection{Splitting the Geometry}

This section will look at alternatives to triangle splitting, namely
\textit{triangle division}, where the triangle is not split by
splitting planes, but divided onto each side, by simply adjusting it's
bounding box, and \textit{box inclusion}, where the triangles
themselves are not tested for inclusion, but their bounding boxes are.

% What to do with the triangles caught in the splitting plane.



\subsubsection{Splitting Triangles}

% Normally ppl split.

\subsubsection{Dividing Triangles}

% Novel scheme? Dvide triangles eg. adjust bounding box instead of
% splitting the triangles.

% Spliting will almost always produce 3 triangles, whereas divide will
% always produce only 2.

% Adjusting area heuristic: When we no longer split geometry, SAH
% becomes an even worse approximation. This can be fixed by an
% adjusting area heuristic, where the diagonal of the geometric
% primitives original bounding box is compared to the diagonal of the
% reduced box and the primitives surface area is adjusted accordingly.


\subsubsection{Adjusting Bounding Boxes}

% Simpler than splitting.

% Inspired by the small node step in Zhou

% Naturally increases amount of \textit{false primitives} in the tree, but is
% very cheap.

% Also has an increased change of looping during construction in
% combination with a small max lower size. Fx fairy forest loops using
% adjusting bounding box with a max size of 32 primtives in leaf nodes.

% False primitives can then be removed at a later stage at the cost of
% some extra overhead. Or combine with Divide every n'th step for
% optimal sweetness.

% With the added leaf intersection in the raytracer, extra triangles
% in the leaf nodes become even less important and this method starts
% to shine for dynamic scenes.


% In conclussion:

% Profile the time it takes to create the different trees, especially
% the splitting kernels.

% Compare amount of nodes.

% Tree traversal time.




\section{Adopting the algorithms for GPGPUs}

% Needs to exploit the dataparallel nature of GPGPU's

% A GPGPU requires (more than) 10^3~10^4 threads for optimal
% performance. To hide latency from texture fetches? cite NVIDIA?

% Use GPU for computations and let CPU handle minor book keeping.

% Handles structures of arrays better than arrays of structures
% chapter 33 \citebook{GPUGEMS2} and coalescence

\subsection{Upper Tree Nodes}

% At upper tree level nodes exploit data parallelism by parallising
% the cost computation over triangles. 

% Use spatiel median splitting for upper nodes. Way faster than SAH
% calculations.

% Creating the KD-tree in BFS will optimize GPU performance at lower
% tree levels, as there would be thousands of nodes created at the
% same time.

% Instead of reducing the sizes of child nodes, I propose a method for
% calculating them directly. This leads to lots of uncoalesced
% lookups, so argue if the GPU is able to properly hide these.

% Building the upper nodes mostly consist of moving data around, and
% not necessarily in a coalesced fashion. This makes it hard to hide
% the latency and will impact performance.

\subsubsection{Empty space splitting}

% Plugable solution, add the new nodes after the ones in nextlist.

% Propagating aabb's downwards

% A good threshold. Did I make it vary and how did that go?

% Perhaps it can be started in it's own stream? At least the actual
% empty space splitting should be able to. Could help out at the early
% tree creation when the GPU is underutilized. Suggest or actually
% try? Would make it an even cheaper optimization.

\subsection{Lower Tree Nodes}

% At lower tree levels where SAH isn't computed parallel, perhaps and
% early out ``good enough'' value/ratio can be given, as done in
% BSP. Might only increase instructions, branching and still wait for
% the slowest thread. (Try and watch it fail) Perhaps without an if
% statement but by arithmetic instead?

% Try persistent threads method!



%% \subsection{Photon Map}

%% \begin{algorithm}
%%   \caption{Photon KD-Tree upper node handling}
%%   \label{alg:PhotonUpperNode}
%%   \begin{algorithmic}
%%     \PROCEDURE{CreateUpperPhotonNodes}
%%               {\VAR{activeList}:list \textit{list of kd-nodes not processed yet}}
%%               {\VAR{lowerList,nextList}:list}{
%%       \STATE{Check size of upper nodes arrays and allocate more if needed.}

%%       \COMMENTIT{Compute bounding box of all active nodes.}
%%       \PARALLELFOR{active node}
%%       \STATE{Compute the bounding box off all it's photons.}
%%       \ENDFOR

%%       \PARALLELFOR{active node}
%%       \STATE{Insert split position, axis and child index}
%%       \ENDFOR

%%       \COMMENTIT{Split photons along axis and store the split index in
%%         the child node}
%%       \FOR{active node}
%%       \STATE{Split the photons in the node \textbf{in parallel}} % Using scan primitives from Sengupta
%%       \ENDFOR

%%       \PARALLELFOR{new node}
%%       \STATE{Split into nextnodes and lowernodes.}
%%       \STATE{Setup links from parents to childrens new position.}
%%       \ENDFOR

%%       \COMMENTIT{CPU bookkeeping}
%%       \COMMENTIT{Perhaps this can be done in a kernel aswell, no need
%%         to do more on the cpu then absolutely necessary.}
%%       \STATE{Copy small child nodes to lowerList}
%%     }
%%   \end{algorithmic}
%% \end{algorithm}


%% \begin{algorithm}
%%   \caption{Lower node handling of the photon kd-tree}
%%   \label{alg:PhotonLowerNode}
%%   \begin{algorithmic}
%%     \PROCEDURE{CreateLowerPhotonNodes}
%%               {\VAR{activeList}:list}
%%               {\VAR{nextList}:list}{
%%                 \PARALLELFOR{node \VAR{i} \textbf{in} activeList}
%%                 \COMMENTIT{Determine optimal splitting plane}
                
%%                 \ASSIGN{\VAR{root}}{\VAR{i.smallRoot}}
%%                 \ASSIGN{\VAR{VVH_0}}{$\|$ \VAR{i.photonBitmap} $\|$}
%%                 \ASSIGN{$VVH$}{$\infty$}
%%                 \STATE{$splitCandidate$}

%%                 \FOR{\textbf{each} splitplane \VAR{s} where s.triangle $\in$ i.photonBitmap}
%%                   \ASSIGN{\VAR{C_L}}{$\| i.triangleSet \cap s.left \|$}
%%                   \ASSIGN{\VAR{C_R}}{$\| i.triangleSet \cap s.right \|$}
%%                   \COMMENTIT{Can't precompute the max and min in splitplane, since triangles change}
%%                   \ASSIGN{$V_L$}{$\sum^k s.max.k - s.min.k + 2 * R$}
%%                   \ASSIGN{$V_L$}{$\sum^k s.max.k - s.min.k + 2 * R$}
%%                   \ASSIGN{$VVH_s$}{$C_L * V_L + C_R * V_R$}
%%                   \IF{$VVH_S < VVH_S$}
%%                     \ASSIGN{$VVH$}{$VVH_S$}
%%                     \ASSIGN{$splitCandidate$}{$s$}
%%                   \ENDIF
%%                 \ENDFOR

%%                 \COMMENTIT{Split to new nodes (Perhaps move this to
%%                   another kernel after doing a scan to determine where
%%                   to place new nodes? Hmm?}

%%                 \ENDFOR
%%               }
%%   \end{algorithmic}
%% \end{algorithm}
