% Ray tracing structures on the GPU has been mapped more or less 100%
% from CPU structures. We need to build them for the GPU instead. That
% means rethinking some of the algorithms (like add persistent
% threads.)



\chapter{Ray Tracing}\label{chp:rayTracing}

\chapterquote{Some argue that in the very long term, rendering may
  best be solved by some variant of ray tracing, in which huge numbers
  of rays sample the environment for the eye’s view of each frame. And
  there will also be colonies on Mars, underwater cities, and personal
  jet packs.}{Tomas Möller and Eric Haines}

% Motivate!

% An optimized ray tracer will be used to test wether or not more time
% spend on creating a better kD tree will pay off in final rendering
% time.

In this chapter we will look at the actual ray tracing and how to
implement it efficiently on the graphics hardware. The result of this
chapter is an optimized ray tracer, that will be used to test the
quality of the kd-tree and wether or not more time spend on creating a
better kD tree will pay off in final rendering time. The chapter is
divided into 4 parts.

Before we discuss the different approaches to ray tracing, we will
first investigate 2 different ray/triangle intersection algorithms and
discuss them with respect to the graphics cards memory hierarchy and
maximizing occupancy.

We will then motivate the use of acceleration structures on the GPU,
by comparing them to an exhaustive ray tracer, where each ray is
tested against all triangles.

Next I present the hierarchical ray tracer and cover how it traverses
the kd-tree created in the previous section. Optimizations will be
added incrementally to the ray tracer and implementation details to
each specific optimization will therefore be discussed alongside the
theory. The optimized ray tracer will use techniques from
\citebook{Aila2009} and \citebook{1230129} along with an optimization
inspired by empty space splitting.

Finally I will briefly discuss shading and how reflection and
refraction is calculated.

\section{Ray/Triangle Intersection}

The inherent diverging behaviour of each ray makes them hard to
parallize efficiently on the graphics card, since data access will be
nearly impossible to coallesce. The solution is to have enough active
rays to effectively hide data fetching latency. This means that each
rays register usage must be kept to a minimum.

Deciding which ray/triangle intersection method to use when ray
tracing can both lower register usage and give a significant
performance boost.

% Consists of 2 parts. Ray/plane intersection which tells us the
% distance the ray will travel, and ray/triangle tests which tells us
% if the ray intersected the triangle.

Ray/triangle intersection can be broken down into 2 parts: A
\textit{ray/plane intersection} test, which computes the signed
distance a ray will have to travel to intersect the plane spanned by a
triangle, and a \textit{triangle inclusion} test, which tells us if
the intersection point was located inside the triangle. The
intersection inclussion test is usually performed by calculating the
intersection points \textit{barycentric coordinates} within the
triangle.

Every point on a triangle, $T$, with vertices $a$, $b$ and $c$ can be
described as 

\begin{displaymath}
  T(u,v) = (1-u-v)a + ub + vc
\end{displaymath}
 
where $(u, v)$ are the barycentric coordinates. For a barycentric
coordinate to be inside $T$ it must fulfill $0 \le u$, $0 \le v$ and
$u+v \le 1$.

Barycentric coordinates are also important for linearly interpolating
vertex attributes, such as normals or colors, across a triangles
surface.

The following 2 ray/triangle intersection methods will both compute
the signed distance and barycentric coordinates for later use when
shading.

\subsection{Möller-Trumbore}

% One of the most popular intersection algorithms and featured in
% Real-Time Rendering.

The Möller-Trumbore algorithm presented in \citebook{MollerTrumbore97}
is one of the most popular algorithms for ray/triangle intersection,
due probably in no small part to it's appearence in chapter 16.8 in
\citebook{RTR3}, but also because it is one of the fastest
ray/triangle intersection algorithms that does not rely on extra
memory and/or precomputations. 

% Calculates the transformation that transform the triangle into the
% unit triangle and applies this transformation to the ray.

The basic idea of their algorithm is to find the affine transformation
that when applied to the triangle, $T(u,v)$, again given by $T(u,v) =
(1-u-v)a + ub + vc$, transforms it into the unit triangle, $U$, which
has vertices $\vecthreeT{0}{0}{0}$, $\vecthreeT{1}{0}{0}$ and
$\vecthreeT{0}{1}{0}$. That affine transformation is then applied to
the ray, $R(t) = O + tD$, which yields the vector
$\vecthreeT{t}{u}{v}$, where $t$ is the distance to the plane spanned
by $T(u,v)$ and $u$ and $v$ are the barycentric coordinates of the
intersection point.

In short this boils down to solving the linear system of equations,
which I will call the \textit{ray/triangle intersection equation}

\begin{displaymath}
  \begin{array}{rl}
    & R(t) = T(u,v) \\
    \Updownarrow \\
    & O + tD = (1-u-v)a + ub + vc \\
  \end{array}
\end{displaymath}

As can be seen in \citebook{MollerTrumbore97}, by rearranging the
terms and applying Cramer's Rule, the solution is

\begin{displaymath}
  \vecthree{t}{u}{v} = \frac{1}{P \cdot E_1} 
  \vecthree{Q \cdot E_2}{P \cdot T}{Q \cdot D}
\end{displaymath}

where $E_1 = b - a$, $E_2 = c - a$, $T = O - a$, $P = D \times  E_2$
and $Q = T \times  E_1$.

\subsubsection{Implementation}

The implementation of this method is pretty straightforward using
CUDA's vector primitives and can be seen in
\refalg{alg:moellerTrumbore}. The implementation provided in
\citebook{MollerTrumbore97} was optimized for CPU and therefore
provided a lot of early out options as soon as the algorithm detects
that the ray has missed the plane. Due to SIMT architecture of GPGPUs,
providing as many early out possibilities as
\citebook{MollerTrumbore97} causes a branching overhead and reduces
performance. This is understandable since only one ray needs to
intersect its triangle in order for the warp to continue testing
intersection. For the ray tracers in this thesis the sweetspot was
found to be only providing an early exit after the ray/plane
intersection.

\begin{algorithm}
  \caption{Möller-Trumbore ray/triangle intersection test}
  \label{alg:moellerTrumbore}
  \begin{algorithmic}
    \PROCEDURE{Möller-Trumbore}
              {$T$ : triangle, $R$ : ray}
              {$hit$ : bool, $t$ : distance, $(u,v)$ : barycentric coordinates}
              {\ASSIGN{$E_1$}{$T.b - T.a$}
                \ASSIGN{$E_2$}{$T.c - T.a$}
                \ASSIGN{$T$}{$R.O - T.a$}
                \ASSIGN{$P$}{$R.D - E_2$}
                \ASSIGN{$Q$}{$T - E_1$}
                \ASSIGN{$determinant$}{$P \cdot E_1$}
                \ASSIGN{$t$}{$(Q \cdot E_2) / determinant$}
                \COMMENTIT{Provide early out if the triangle is behind
                  the ray.}
                \IF{$0 < t$}
                  \ASSIGN{$u$}{$(P \cdot T) / determinant$}
                  \ASSIGN{$v$}{$(Q \cdot R.D) / determinant$}
                  \ASSIGN{$hit$}{$0 \le u$ \textbf{and} $0 \le v$
                    \textbf{and} $u+v \le 1$}
                \ELSE
                  \ASSIGN{$hit$}{$false$}
                \ENDIF
              }
  \end{algorithmic}
\end{algorithm}

\subsection{Woop}

% Why Woop is better

While the Möller-Trumbore ray/triangle intersection approach requires
minimal storage, it does unfortunatly require quite a lot of
registers, since it needs to both store the ray information aswell as
the determinant and the matrix $\vecthreeT{Q \cdot E_2}{P \cdot T}{Q
  \cdot D}$. The high register usage can be remedied by performing
precalulations per triangle as described in Chapter 5 of Sven Woops
diploma thesis\citebook{woop:04:diplom}. This unfortunatly also means
a higher storage requirement for a scene.

% Also translates the ray using the unit triangle.

As was the case with the Möller-Trumbore approach, Woops approach also
transforms the generel ray/triangle intersection problem into a
ray/unit triangle intersection problem, where the solution is
trivially calculated.

He observed that the triangle, $T$, can be transformed into the unit
triangle, $U$, via an affine transformation, consisting of a rotation
matrix, $m$, and a translation, $n$.

\begin{displaymath}
  U_v = m T_v + n, v \in \{a, b, c\}
\end{displaymath}

The inverse affine transformation is the one that transforms the unit
triangle into $T$.

\begin{displaymath}
  T_v = m' U_v + n', v \in \{a, b, c\}, m' = m^{-1}, n' = -m^{-1}n
\end{displaymath}

Given that we already know $T$ and $U$, $m'$ and $n'$ can be
constructed as follows

\begin{displaymath}
  m' = \left[ T_a - T_c, T_b - T_c, (T_a - T_c) \times (T_b - T_c)
    \right],
  n = T_c
\end{displaymath}

We can then derive $m$ and $n$ from $m'$ and $n'$. 

\begin{displaymath}
  m = (m')^{-1},
  n = - m n'
\end{displaymath}

This requires $m'$ to be invertable, which it always is for
\textit{non-degenerate triangles}\footnote{A degenerate triangles is
  a triangles that has collapsed into a line.}.

%% Applying the affine transformation described by $m$ and $n$ to the
%% ray/triangle intersection equation we get

%% \begin{displaymath}
%%   \begin{array}{rl}
%%     & m R(t) + n = m T(u,v) + n\\
%%     \Updownarrow \\
%%     & m (O + tD) + n = m ((1-u-v)a + ub + vc) + n \\
%%     \Updownarrow \\
%%     & m (O + tD) + n = (1-u-v)U_a + u U_b + v U_c \\
%%   \end{array}
%% \end{displaymath}

Applying the affine transformation described by $m$ and $n$ to the
ray, $m * R(t) + n = R'(t) = tD' + O'$, it is transformed into the
same space as the unit triangle. Computing the distance, $t$, and
barycentric coordinates, $(u,v)$ then becomes trivial.

\begin{displaymath}
  \begin{array}{l}
    t = - D'_z / O'_z \\
    u = t D'_x + O'_x \\
    v = t D'_y + O'_y
  \end{array}
\end{displaymath}

Since each dimension in $R'$ can be computed independently, we get 

\begin{displaymath}
  \begin{array}{l}
    t = - (m_z \cdot D + n_z) / (m_z \cdot O) \\
    u = t (m_x \cdot D + n_x) + m_x \cdot O \\
    u = t (m_y \cdot D + n_y) + m_y \cdot O \\
  \end{array}
\end{displaymath}

where $m_i$ is the i'th row of $m$.

\subsubsection{Implementation}

The implementation is strightforward. $m$ and $n$ are computed and
stored in 4 component vectors as $w_i = \left[m_i, n_i \right]$ prior
to ray tracing. When the ray tracer performs ray/triangle
intersection, each $w_i$ vector can then be loaded into register
memory one vector at a time. Compared to the Möller-Trumbore approach
this saves X registers and yields a sizeable performance increase, as
can be seen in \reffig{TODO result section figure}.

% The extra space used by the precalcultations can be mitigated if
% the vertices are no longer needed.




\section{Exhaustive Ray Tracing}

% GPU does bruteforcing well.

% Cite paper on kNN done on the GPU.

% Algorithm

% Why even use datastructures on the GPU. They work wonders on the CPU
% but for the GPU they might hinder performance (cite KNN paper and
% dataparallism example with 31 threads waiting)


\section{Hierarchical Ray Tracing}

% Brief introduction to several acceleration techniques. BVH, KD,
% quad/oct trees and BSP.

% KD-trees are ze leetzors according to Havran? Another motivation is
% Zhou's paper on fast KD tree construction.

\subsection{KD-restart}

% KD restart is the simplest and fastest.

% Start with kd restart, simple to get up and running.

\begin{algorithm}
  \caption{KD Restart}
  \label{alg:KDRestart}
  \begin{algorithmic}
    \PROCEDURE{KDRestart}
              {$ray$ : Ray}
              {$t_{min}$ : Integer}{
                \ASSIGN{$t_{min}$}{$0$}
                \WHILE{$t_{min} < \infty$}
                  \ASSIGN{$t_{next}$}{$\infty$}
                  \ASSIGN{$node$}{$root$}
                  \COMMENTIT{Traverse the tree until a leaf node is reached}
                  \WHILE{$node.info \neq LEAF$}
                    \ASSIGN{$t_{split}$}{($node.splitValue - ray.origin[node.axis]) / ray.direction[node.axis]$}
                    \IF{$t_{min} < t_{split}$}
                      \ASSIGN{$node$}{$ray.direction[node.axis] > 0$ ? $node.left$ : $node.right$}
                      \ASSIGN{$t_{next}$}{min$(t_{split}, t_{next})$}
                    \ELSE
                      \ASSIGN{$node$}{$ray.direction[node.axis] > 0$ ? $node.right$ : $node.left$}
                    \ENDIF
                  \ENDWHILE
                  \COMMENTIT{Advance the ray to the next splitting plane.}
                  \ASSIGN{$t_{min}$}{$t_{next}$}
                  \COMMENTIT{Test intersection with the leafs primitives}
                  \FOREACH{$triangle$}{$node.triangles$}
                    \ASSIGN{$t_{min}$}{\MIN{$(t_{min}}{$\textbf{Intersect}$(triangle, ray))$}}
                  \ENDFOR
                \ENDWHILE
                \STATE{\bf{return} $t_{min}$}
              }
  \end{algorithmic}
\end{algorithm}

\subsection{Packets}

% Packets: 2x2 packets on the CPU for to take advantage of SIMD
% instructions (Wald), warp size packets on the GPU. While
% \citebook{1230129} implemented packets, they merely assumed it would
% yield a speedup and did not provide any results. Aila2009 is against
% packets as they in practice seem to make it slower.

% As ray tracing becomes more complex packets also become less
% effective, as rays will become more chaotic in nature and less
% likely to fit into packets.

% I will adobt a pretty cheap packet strategy: I will trace my rays in
% 4x8 packets to increase ray coherence across warps.

\subsection{Short stack}

% Only push usefull 'forward' nodes to the stack.

\begin{algorithm}
  \caption{Short stack}
  \label{alg:ShortStack}
  \begin{algorithmic}
    \PROCEDURE{ShortStack}
              {$ray$ : Ray}
              {$t_{min}$ : Integer}{
    \ASSIGN{$t_{min}$}{$0$}
    \WHILE{$t_{min} < \infty$}
      \IF{$\color{green}stack.IsEmpty$}
        \ASSIGN{$node$}{$root$}
        \ASSIGN{$t_{next}$}{$\infty$}
      \ELSE
        \color{green}\ASSIGN{$(node, t_{next})$}{stack.pop}
      \ENDIF
      \COMMENTIT{Traverse the tree until a leaf node is reached}
      \WHILE{$node.info \neq LEAF$}
        \ASSIGN{$t_{split}$}{($node.splitValue - ray.origin[node.axis]) / ray.direction[node.axis]$}
        \IF{$t_{min} < t_{split}$}
          \ASSIGN{$node$}{$ray.direction[node.axis] > 0$ ? $node.left$ : $node.right$}
          \IF{$\color{green}t_{split} < t_{next}$}
            \color{green}\STATE{stack.push($upperChild, t_{next}$)}
          \ENDIF
          \ASSIGN{$t_{next}$}{min$(t_{split}, t_{next})$}
        \ELSE
          \ASSIGN{$node$}{$ray.direction[node.axis] > 0$ ? $node.right$ : $node.left$}
        \ENDIF
      \ENDWHILE
      \COMMENTIT{Advance the ray to the next splitting plane.}
      \ASSIGN{$t_{min}$}{$t_{next}$}
      \COMMENTIT{Test intersection with the leafs primitives}
      \FOREACH{$triangle$}{$node.triangles$}
        \ASSIGN{$t_{min}$}{min$(t_{min}, $\bf{Intersect}$(triangle, ray))$}
      \ENDFOR
    \ENDWHILE
    \STATE{\bf{return} $t_{min}$}
              }
  \end{algorithmic}
\end{algorithm}

\subsection{Skipping Leaf Nodes}

% Inspired by empty space splitting.

% Combines BVH and KD tree

\subsection{Push Down}

I will not be implementing the push-down approach from
\citebook{1230129}. While it will most likely improve the generel ray
tracing case, where some of the geometry will be located behind the
rays and can safely be excluded, it will only add an overhead to worst
case situations, where the uppermost splitting plane is intersected by
the rays.

\subsection{Ropes}

% stackless raytracing using ropes. 
% Place in future works?

\subsection{Persistent Threads}

% Use persistent threads / own scheduler. Aila2009.

\subsection{Caching 'hot' nodes}

% wrap node and geometry arrays in textures to utilize cache? Or
% simply don't care and refere to cached global memory in future
% GPU's?

% Like persistent threads, this is not an important optimazition
% longterm, since global memory are being given a cache.



\section{Shading}

% Everything is paper thin and empty space
