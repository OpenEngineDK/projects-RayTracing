% Ray tracing structures on the GPU has been mapped more or less 100%
% from CPU structures. We need to build them for the GPU instead. That
% means rethinking some of the algorithms (like add persistent
% threads.)



\chapter{Ray Tracing}\label{chp:rayTracing}

\chapterquote{Some argue that in the very long term, rendering may
  best be solved by some variant of ray tracing, in which huge numbers
  of rays sample the environment for the eye’s view of each frame. And
  there will also be colonies on Mars, underwater cities, and personal
  jet packs.}{Tomas Möller and Eric Haines}

% Motivate!

% An optimized ray tracer will be used to test wether or not more time
% spend on creating a better kD tree will pay off in final rendering
% time.

The focus of this chapter will be the actual ray tracing and how to
implement it efficiently on the graphics hardware. The result will be
an optimized ray tracer, that will be used to test the quality of the
kd-tree and wether or not more time spend on creating a better kD tree
will pay off in final rendering time. The chapter is divided into 4
parts.

Before discussing the different approaches to ray tracing, we will
investigate 2 different ray/triangle intersection algorithms and
discuss them with respect to the graphics cards memory hierarchy and
maximizing occupancy.

The implementation of an exhaustive ray tracer, where each ray is
tested against all triangles, will then briefly be discussed. In
\refchapter{chp:results} it will be compared to the hierachical
version to motivate the continued use of data structures on GPGPU's.

Next the hierarchical ray tracer implementes and optimizations are
presented. This section will cover how to traverse the kd-tree created
in the previous section. The optimizations will be added incrementally
to the ray tracer and implementation details to each specific
optimization will therefore be discussed alongside the theory. The
optimized ray tracer will use techniques from \citebook{Aila2009} and
\citebook{1230129} along with an optimization inspired by empty space
splitting.

Finally I will briefly discuss shading and how reflections and
refractions are calculated.

\section{Ray/Triangle Intersection}

The inherent diverging behaviour of each ray makes them hard to
parallize efficiently on the graphics card, since data access will be
nearly impossible to coallesce. The solution is to have enough active
rays to effectively hide data fetching latency. This means that each
rays register usage must be kept to a minimum, in order to have room
for as many active warps as possible.

Deciding which ray/triangle intersection method to use when ray
tracing can both lower register usage and yield a significant
performance boost.

% Consists of 2 parts. Ray/plane intersection which tells us the
% distance the ray will travel, and ray/triangle tests which tells us
% if the ray intersected the triangle.

Ray/triangle intersection and can be broken down into 2 parts: A
\textit{ray/plane intersection} test, which computes the signed
distance a ray will have to travel to intersect the plane spanned by a
triangle, and a \textit{triangle inclusion} test, which tells us if
the intersection point was located inside the triangle. The
intersection inclussion test is usually performed by calculating the
intersection points \textit{barycentric coordinates} within the
triangle.

Every point on a triangle, $T$, with vertices $a$, $b$ and $c$, can be
described as

\begin{displaymath}
  T(u,v) = (1-u-v)a + ub + vc
\end{displaymath}
 
where $(u, v)$ are the aforementioned barycentric coordinates. For a
barycentric coordinate to be inside $T$ it must fulfill $0 \le u$, $0
\le v$ and $u+v \le 1$.

Just as barycentric coordinates are used to linearly interpolate the
vertex positions across the triangle, they are also important for
interpolating other vertex attributes, such as normals or colors.

The following 2 ray/triangle intersection methods will both compute
the signed distance and barycentric coordinates for later use when
shading.

\subsection{Möller-Trumbore}

% One of the most popular intersection algorithms and featured in
% Real-Time Rendering.

The Möller-Trumbore algorithm presented in \citebook{MollerTrumbore97}
is one of the most popular algorithms for ray/triangle intersection,
probably in no small part due to it's appearence in chapter 16.8 in
\citebook{RTR3}, but also because it is one of the fastest
ray/triangle intersection algorithms that does not rely on extra
memory and/or precomputations.

% Calculates the transformation that transform the triangle into the
% unit triangle and applies this transformation to the ray.

The basic idea of their algorithm is to find the affine transformation
that when applied to the triangle $T(u,v)$, transforms it into the unit
triangle, $U$, which has vertices $\vecthreeT{0}{0}{0}$,
$\vecthreeT{1}{0}{0}$ and $\vecthreeT{0}{1}{0}$. That affine
transformation is then applied to the ray, $R(t) = O + tD$, which
yields the vector $\vecthreeT{t}{u}{v}$, where $t$ is the distance to
the plane spanned by $T(u,v)$ and $u$ and $v$ are the barycentric
coordinates of the intersection point.

In short this boils down to solving the linear system of equations,
which I will call the \textit{ray/triangle intersection equation}

\begin{displaymath}
  \begin{array}{rl}
    & R(t) = T(u,v) \\
    \Updownarrow \\
    & O + tD = (1-u-v)a + ub + vc \\
  \end{array}
\end{displaymath}

As can be seen in \citebook{MollerTrumbore97}, by rearranging the
terms and applying Cramer's Rule, the solution is

\begin{displaymath}
  \vecthree{t}{u}{v} = \frac{1}{P \cdot E_1} 
  \vecthree{Q \cdot E_2}{P \cdot T}{Q \cdot D}
\end{displaymath}

where $E_1 = b - a$, $E_2 = c - a$, $T = O - a$, $P = D \times  E_2$
and $Q = T \times  E_1$.

\subsubsection{Implementation}

The implementation of this method is pretty straightforward using
CUDA's vector primitives and can be seen in
\refalg{alg:moellerTrumbore}. The implementation provided in
\citebook{MollerTrumbore97} was optimized for the CPU and therefore
provided a lot of early out options as soon as the algorithm detected
that the ray had missed the plane. Due to the SIMT architecture of
GPGPUs, providing as many early out possibilities as
\citebook{MollerTrumbore97} causes a branching overhead and results in
reduced performance. This is understandable since only one ray needs
to intersect its triangle in order for the entire warp to perform the
complete intersection testing. For the ray tracers in this thesis the
sweetspot was found to be only providing an early exit after the
ray/plane intersection.

\begin{algorithm}
  \caption{Möller-Trumbore ray/triangle intersection test}
  \label{alg:moellerTrumbore}
  \begin{algorithmic}
    \PROCEDURE{Möller-Trumbore}
              {$T$ : triangle, $R$ : ray}
              {$hit$ : bool, $t$ : distance, $(u,v)$ : barycentric coordinates}
              {\ASSIGN{$E_1$}{$T.b - T.a$}
                \ASSIGN{$E_2$}{$T.c - T.a$}
                \ASSIGN{$T$}{$R.O - T.a$}
                \ASSIGN{$P$}{$R.D - E_2$}
                \ASSIGN{$Q$}{$T - E_1$}
                \ASSIGN{$determinant$}{$P \cdot E_1$}
                \ASSIGN{$t$}{$(Q \cdot E_2) / determinant$}
                \COMMENTIT{Provide early out if the triangle is behind
                  the ray.}
                \IF{$0 < t$}
                  \ASSIGN{$u$}{$(P \cdot T) / determinant$}
                  \ASSIGN{$v$}{$(Q \cdot R.D) / determinant$}
                  \ASSIGN{$hit$}{$0 \le u$ \textbf{and} $0 \le v$
                    \textbf{and} $u+v \le 1$}
                \ELSE
                  \ASSIGN{$hit$}{$false$}
                \ENDIF
              }
  \end{algorithmic}
\end{algorithm}

\subsection{Woop}

% Why Woop is better

While the Möller-Trumbore ray/triangle intersection approach requires
minimal storage, it does unfortunatly require quite a lot of
registers, since it needs to both store the ray's parameters aswell as
the determinant and the matrix $\vecthreeT{Q \cdot E_2}{P \cdot T}{Q
  \cdot D}$. The high register usage can be remedied by performing
precalulations per triangle as described in Chapter 5 of Sven Woops
diploma thesis\citebook{woop:04:diplom}. The trade-off is a higher per
triangle storage requirement for the scene.

% Also translates the ray using the unit triangle.

As was the case with the Möller-Trumbore approach, Woops approach also
transforms the generel ray/triangle intersection problem into a
ray/unit triangle intersection problem, where the solution is
trivially calculated.

He observed that the triangle, $T$, can be transformed into the unit
triangle, $U$, via an affine transformation, consisting of a rotation
matrix, $m$, and a translation, $n$.

\begin{displaymath}
  U_v = m T_v + n, v \in \{a, b, c\}
\end{displaymath}

The inverse affine transformation is the one that transforms the unit
triangle into $T$.

\begin{displaymath}
  T_v = m' U_v + n', v \in \{a, b, c\}, m' = m^{-1}, n' = -m^{-1}n
\end{displaymath}

Given that we already know $T$ and $U$, $m'$ and $n'$ can be
constructed as follows

\begin{displaymath}
  m' = \left[ T_a - T_c, T_b - T_c, (T_a - T_c) \times (T_b - T_c)
    \right],
  n = T_c
\end{displaymath}

We can then derive $m$ and $n$ from $m'$ and $n'$. 

\begin{displaymath}
  m = (m')^{-1},
  n = - m n'
\end{displaymath}

This requires $m'$ to be invertable, which it always is for
\textit{non-degenerate triangles}\footnote{A degenerate triangles is
  a triangles that has collapsed into a line or a point.}.

%% Applying the affine transformation described by $m$ and $n$ to the
%% ray/triangle intersection equation we get

%% \begin{displaymath}
%%   \begin{array}{rl}
%%     & m R(t) + n = m T(u,v) + n\\
%%     \Updownarrow \\
%%     & m (O + tD) + n = m ((1-u-v)a + ub + vc) + n \\
%%     \Updownarrow \\
%%     & m (O + tD) + n = (1-u-v)U_a + u U_b + v U_c \\
%%   \end{array}
%% \end{displaymath}

Applying the affine transformation described by $m$ and $n$ to the
ray, $m * R(t) + n = R'(t) = tD' + O'$, it is transformed into the
same space as the unit triangle. Computing the distance, $t$, and
barycentric coordinates, $(u,v)$ then becomes trivial.

\begin{displaymath}
  \begin{array}{l}
    t = - D'_z / O'_z \\
    u = t D'_x + O'_x \\
    v = t D'_y + O'_y
  \end{array}
\end{displaymath}

Since each dimension in $R'$ can be computed independently, we get 

\begin{displaymath}
  \begin{array}{l}
    t = - (m_z \cdot D + n_z) / (m_z \cdot O) \\
    u = t (m_x \cdot D + n_x) + m_x \cdot O \\
    u = t (m_y \cdot D + n_y) + m_y \cdot O \\
  \end{array}
\end{displaymath}

where $m_i$ is the i'th row of $m$.

\subsubsection{Implementation}

The implementation is strightforward. $m$ and $n$ are computed and
stored in 4 component vectors as $w_i = \left[m_i, n_i \right]$ prior
to ray tracing. During ray/triangle intersection each $w_i$ vector can
then be loaded into register memory one vector at a time. Compared to
the Möller-Trumbore approach this saves 3 registers and yields a
sizeable performance increase, as can be seen in \reffig{TODO result
  section figure}. \fixme{TODO result section figure.}

% early out

As in the implementation of Möller-Trumbore, the Woop implementation
also only has one early out option, which is placed right after the
distance calculation.

% The extra space used by the precalcultations can be mitigated if
% the vertices are no longer needed.

Finally, the extra memory required for precalculating $m$ and $n$ can
be mitigated if the triangles vertex positions are replaced by
$m$. This is only possible however, if the vertices are not used
elsewhere in the ray tracer.


\section{Exhaustive Ray Tracing}

Before directing our focus to the hierarchical ray tracers, we will
first take a look at an exhaustive ray tracer.

% GPU does bruteforcing well.

The reason that an exhaustive ray tracer is interesting is that the
graphics card comes with high computational power, but little
tolerance for branching. An exhaustive ray tracer fits very well into
such an architecture. Having to intersect every ray with every
triangle certainly requires a lot of computational power, and every
ray in a warp will loop over the same rays, so the triangle-loop will
not cause thread divergence.

% Algorithm

The per ray algorithm itself is presented in
\refalg{alg:exhaustive}. The actual ray tracers implemented in this
thesis also compute the barycentric coordinates and returns a
reference to the intersected geometric primitive, which is used for
shading. In order to keep the algorithms simple these have been
omitted and instead we only focus on computing the signed distance,
$t_{min}$, to the intersected primitive.

\begin{algorithm}
  \caption{Exhaustive ray tracer}
  \label{alg:exhaustive}
  \begin{algorithmic}
    \PROCEDURE{Exhaustive}
              {$R$ : Ray, $Ts$, Triangle List}
              {$t_{min}$ : Number}{
                \ASSIGN{$t_{min}$}{$\infty$}
                \FOREACH{$T$}{$Ts$}
                  \ASSIGN{$t_{min}$}{\MIN{$(t_{min}}{$\textbf{Intersect}$(T, R))$}}
                \ENDFOR
              }
  \end{algorithmic}
\end{algorithm}

The downside to the exhaustive approach is that for $n$ rays and $m$
triangles the time complexity becomes $O(nm)$.

\section{Hierarchical Ray Tracing}

% Time complexity of O(n log m)

Hierarchical ray tracers provide a better upper bound than an
exhaustive ray tracer. Given a hierachical data structure over $m$
geometric primitives in a scene, then the nearest leaf node can be
found in $O(\log m)$ time. For $n$ rays this yields a time complexity
of $O(n \log m)$.

% Describe how the tree is traversed

When ray tracing a scene divided by a kd-tree, each ray needs to
traverse the tree and find the nearest leaf node. At each interior
node, the ray needs to determine which of the child nodes are closest,
in front of the ray and then traverse that node until it reaches a
leaf node. At the leaf the ray needs to intersect each triangle in the
leaf and determine which intersected triangle is closest, if any. If
the ray intersects a triangle, then it reports this intersection, if
not then it needs to continue traversing the tree. How this is done is
the topic of \refsection{sec:kdRestart} and
\refsection{sec:shortStack}. The generel algorithm for ray tracing a
kd-tree can be seen in \refalg{alg:generelTraversal}.

\begin{algorithm}
  \caption{A general kd-tree ray tracing algorithm}
  \label{alg:generelTracing}
  \begin{algorithmic}
    \PROCEDURE{KDTraversal}
              {$ray$ : Ray, $tree$ : kd-tree}
              {$t_{min}$ : Number}{
                \ASSIGN{$t_{min}$}{$0$}
                \WHILE{ray hasn't intersected}
                  \COMMENTIT{Traverse the tree until the closest leaf is found
                    and store the distance to the closest splitting
                    plane in $t_{split}$.}
                  \ASSIGN{$(leaf, t_{split})$}{Traverse($ray, tree$)}
                  \COMMENTIT{Intersect triangles in leaf and return
                    closest intersection.}
                  \ASSIGN{$t_{hit}$}{Intersect($ray, leaf.triangles$)}
                  \COMMENTIT{Break if a closest intersection
                    is found and assign to $t_{min}$.}
                  \IF{$t_{hit} < t_{split}$}
                    \ASSIGN{$t_{min}$}{$t_{hit}$}
                    \STATE{\textbf{break}}
                  \ELSE
                    \ASSIGN{$t_{min}$}{$t_{split}$}
                  \ENDIF
                \ENDWHILE
              }
  \end{algorithmic}
\end{algorithm}

% Traversal method

The method used to determine which of an interior node's children to
visit next can be seen in \refalg{alg:generelTraversal}. For each
interior node the ray first needs to determine which of the 2 children
are placed \textit{nearest} and \textit{farthest} along the rays
direction. It then computes the signed distance from the ray to the
nodes splitting plane. If this distance is below 0 then the plane is
located behind the ray and the farthest child is visited. If the
distance is above 0 then the nearest node needs to be visited next. In
addition the distance to the nearest splitting plane in front of the
ray needs to be updated. This information is used to advance the ray
beyond a visited leaf node if it did not intersect any primitives.

\begin{algorithm}
  \caption{A basic kd-tree traversal algorithm}
  \label{alg:generelTraversal}
  \begin{algorithmic}
    \PROCEDURE{Traversal}
              {$ray$ : Ray, $tree$ : kd-tree}
              {$leaf$ : Node, $t_{far}$ : Number}{
                \ASSIGN{$t_{far}$}{$\infty$}
                \ASSIGN{$node$}{$tree.root$}
                \WHILE{$node \neq LEAF$}
                  \COMMENTIT{The signed distance to the nodes splitting plane.}
                  \ASSIGN{$node_{near}$}{$ray.direction[node.axis] > 0$ ? $node.left$ : $node.right$}
                  \ASSIGN{$node_{far}$}{$ray.direction[node.axis] > 0$ ? $node.right$ : $node.left$}
                  \ASSIGN{$t_{split}$}{($node.splitValue - ray.origin[node.axis]) / ray.direction[node.axis]$}
                  \IF{$0 < t_{split}$}
                    \ASSIGN{$node$}{$node_{near}$}
                    \ASSIGN{$t_{far}$}{min$(t_{split}, t_{far})$}
                  \ELSE
                    \ASSIGN{$node$}{$node_{far}$}
                  \ENDIF
                \ENDWHILE
              }
  \end{algorithmic}
\end{algorithm}

In \reffig{fig:simpleScene} a simple scene consisting of 4 triangles
is shown. The corrosponding kd-tree matching the axis aligned
splitting planes is shown in \reffig{fig:simpleTree}. A tree traversal
of the ray, $R(t) = t \vectwoT{2}{1} + \vectwoT{0}{1}$, entering the
scene in the lower left would look like this: Upon entering the scene
the ray first visits the root node, 0. Node 0 splits the scene along
the x-axis at position 4 and the rays distance to that plane is then
$(4 - 0) / 2 = 2$. The ray therefore proceeds to the childnode $2 > 0
? 1 : 2 = 1$. The signed distance to node 1's splitting plane is $(4 -
1) / 1 = 3$ and the ray proceeds to node $1 > 0 ? 3 : 2 = 3$, where it
finds no primitives to intersect. The ray is then advance by the
minimum splitting distance, which was 2, and becomes $R'(t) = R(t) + 2
\vectwoT{2}{1} = t \vectwoT{2}{1} + \vectwoT{4}{3}$. Since the ray did
not intersect any geometry and has not advanced beyond the scene, the
traversal process is restarted for $R'(t)$.


\begin{figure}
  \centering
  \subfloat[A simple scene divided by a kd-tree.]{
    \begin{tikzpicture}[y=0.5cm, x=0.5cm,font=\sffamily]
      \drawNode{0,0}{8,0}{8,6}{0,6}

      % Tris
      \drawTri{0,6}{1,4}{2,5}
      \draw (1,5) node{0};
      \drawTri{4,6}{3,4}{2,5}
      \draw (3,5) node{1};
      \drawTri{4,2}{5,6}{6,4}
      \draw (5,4) node{2};
      \drawTri{8,0}{7,2}{6,1}
      \draw (7,1) node{3};

      % Splits
      \draw (4,0) -- (4,6);
      \draw (0,4) -- (4,4);
      \draw (2,4) -- (2,6);
      \draw (4,2) -- (8,2);

      % Ray
      \drawRay{0,1}{2,2}

      %axes
      \draw[->] (0,0) -- coordinate (x axis mid) (9,0);
      \draw[->] (0,0) -- coordinate (y axis mid) (0,7);
    	%ticks
    	\foreach \x in {0,2,...,9}
     		\draw (\x,1pt) -- (\x,-3pt)
			node[anchor=north] {\x};
    	\foreach \y in {0,2,...,7}
     		\draw (1pt,\y) -- (-3pt,\y) 
     			node[anchor=east] {\y}; 
    \end{tikzpicture}
    \label{fig:simpleScene}
  }
  \hspace{20pt}
  \subfloat[The kd-tree matching the scene. Nodes contain information
    about which axis have been divided and where. Leaf nodes contain a
    set of the triangles they overlap.]{
    \begin{tikzpicture}[y=0.5cm, x=.5cm,font=\sffamily,
        level/.style={sibling distance=40mm/#1}]
      \node [node] (0){$\begin{array}{c}0\\x:4\end{array}$}
        child {node [node] (1) {$\begin{array}{c}1\\y:4\end{array}$}
          child {node [leaf] (e) {$\begin{array}{c}3\\\emptyset\end{array}$}}
          child {node [node] (3) {$\begin{array}{c}4\\x:2\end{array}$}            
            child {node [leaf] (e) {$\begin{array}{c}7\\\{0\}\end{array}$}}
            child {node [leaf] (e) {$\begin{array}{c}8\\\{1\}\end{array}$}}
          }
        }
        child {node [node] (2) {$\begin{array}{c}2\\y:2\end{array}$}
            child {node [leaf] (e) {$\begin{array}{c}5\\\{2\}\end{array}$}}
            child {node [leaf] (e) {$\begin{array}{c}6\\\{3\}\end{array}$}}
        };
    \end{tikzpicture}
    \label{fig:simpleTree}
  }
  \caption{}
  \label{fig:simpleSceneTree}
\end{figure}


\subsection{KD-restart}\label{sec:kdRestart}

% KD restart is the simplest and fastest.

The approach presented above, where kd-tree traversal is restarted at
the root node, is known as \textit{KD-restart} and is one of the
simplest algorithms for ray tracing kd-trees.

% Instead of advancing the ray simply update tMin

The algorithm in it's entirety is presented in
\refalg{alg:KDRestart}. Instead of advancing the ray by updating it's
origin, a signed distance, $t_{min}$ is used.

\begin{algorithm}
  \caption{KD Restart}
  \label{alg:KDRestart}
  \begin{algorithmic}
    \PROCEDURE{KDRestart}
              {$ray$ : Ray, $tree$ : kd-tree}
              {$t_{min}$ : Number}{
                \ASSIGN{$t_{min}$}{$0$}
                \WHILE{$t_{min} < \infty$}
                  \ASSIGN{$t_{next}$}{$\infty$}
                  \ASSIGN{$node$}{$tree.root$}
                  \COMMENTIT{Traverse the tree until a leaf node is reached}
                  \WHILE{$node \neq LEAF$}
                    \ASSIGN{$t_{split}$}{($node.splitValue - ray.origin[node.axis]) / ray.direction[node.axis]$}
                    \IF{$t_{min} < t_{split}$}
                      \ASSIGN{$node$}{$ray.direction[node.axis] > 0$ ? $node.left$ : $node.right$}
                      \ASSIGN{$t_{next}$}{min$(t_{split}, t_{next})$}
                    \ELSE
                      \ASSIGN{$node$}{$ray.direction[node.axis] > 0$ ? $node.right$ : $node.left$}
                    \ENDIF
                  \ENDWHILE
                  \COMMENTIT{Advance the ray to the next splitting plane.}
                  \ASSIGN{$t_{min}$}{$t_{next}$}
                  \COMMENTIT{Test intersection with the leafs primitives}
                  \FOREACH{$triangle$}{$node.triangles$}
                    \ASSIGN{$t_{min}$}{\MIN{$(t_{min}}{$\textbf{Intersect}$(triangle, ray))$}}
                  \ENDFOR
                  \IF{$t_{min} < t_{next}$}
                    \STATE{\textbf{break}}
                  \ENDIF
                \ENDWHILE
              }
  \end{algorithmic}
\end{algorithm}

\subsection{Short stack}\label{sec:shortStack}

% Kd-Restart traverses many of the same nodes, because 

When a ray triggers a restart in kd-restart, it will almost always
traverse many of the same tree nodes as it did in its previous
traversel. The reason for this is that kd-trees will often store
spatially local nodes as local nodes in the tree. CPU ray tracers
solve this problem by pushing the not-visited child of an interior
node onto a stack and then restarting from the first node on that
stack. This can save a lot of resources otherwise spend on traversing
the tree, since the ray will now restart much closer to the leaf
nodes.

The memory model of the GPGPU however isn't flexible enough for this
approach, which requires either dynamically allocating more memory if
the stack is filled or pre-allocating a \textit{large enough} stack in
local memory to handle any given kd-tree, something that could require
quite large amounts memory for huge scenes and might even require too
much memory for practical use on todays graphics cards. The solution
found by \horn{} was to use a \textit{short-stack}, a fixed-size,
circular stack of $N$ elements, and then revert to using kd-restart
if the stack underflows. In their research they found that a
short-stack approach only visited 3\% more nodes compared to the
unlimited stack CPU approach.

% Only push usefull 'forward' nodes to the stack.

Obviously all child nodes can not be pushed onto the stack, as that
would force the rays to visit the entire kd-tree. Therefore
restrictions as to which nodes should be considered needs to be
formulated. The first restriction is not to push nodes behind the ray,
since the ray can never intersect them. The second restriction is not
to push nodes whose splitting planes distance is greater than
$t_{next}$, as these would never be visited in a kd-restart
traversal. The reasoning behind this is that if a ray advances beyond
the splitting plane of a higher interior node, it effectively means
the ray should never visit that nodes nearest subtree again and
therefore no nodes from that subtree should be stored in the
short-stack. The changes made to kd-restart to facilitate a
short-stack is marked in green in \refalg{alg:ShortStack}.

\begin{algorithm}
  \caption{Short stack}
  \label{alg:ShortStack}
  \begin{algorithmic}
    \PROCEDURE{ShortStack}
              {$ray$ : Ray, $tree$ : kd-tree}
              {$t_{min}$ : Number}{
    \ASSIGN{$t_{min}$}{$0$}
    \WHILE{$t_{min} < \infty$}
      \IF{$\color{green}stack.IsEmpty$}
        \ASSIGN{$node$}{$tree.root$}
        \ASSIGN{$t_{next}$}{$\infty$}
      \ELSE
        \color{green}\ASSIGN{$(node, t_{next})$}{stack.pop}
      \ENDIF
      \COMMENTIT{Traverse the tree until a leaf node is reached}
      \WHILE{$node \neq LEAF$}
        \ASSIGN{$t_{split}$}{($node.splitValue - ray.origin[node.axis]) / ray.direction[node.axis]$}
        \IF{$t_{min} < t_{split}$}
          \ASSIGN{$node$}{$ray.direction[node.axis] > 0$ ? $node.left$ : $node.right$}
          \IF{$\color{green}t_{split} < t_{next}$}
            \color{green}\STATE{stack.push($upperChild, t_{next}$)}
          \ENDIF
          \ASSIGN{$t_{next}$}{min$(t_{split}, t_{next})$}
        \ELSE
          \ASSIGN{$node$}{$ray.direction[node.axis] > 0$ ? $node.right$ : $node.left$}
        \ENDIF
      \ENDWHILE
      \COMMENTIT{Advance the ray to the next splitting plane.}
      \ASSIGN{$t_{min}$}{$t_{next}$}
      \COMMENTIT{Test intersection with the leafs primitives}
      \FOREACH{$triangle$}{$node.triangles$}
        \ASSIGN{$t_{min}$}{\MIN{$(t_{min}}{$\bf{Intersect}$(triangle, ray))$}}
      \ENDFOR
      \IF{$t_{min} < t_{next}$}
        \STATE{\textbf{break}}
      \ENDIF
    \ENDWHILE
              }
  \end{algorithmic}
\end{algorithm}

% Example

Let us look at a simple example of how the short-stack will speedup
traversal. Using \reffig{fig:simpleSceneTree} as our scene again, we
saw previously that the ray, $R(t) = t \vectwoT{2}{1} +
\vectwoT{0}{1}$, will traverse nodes 0, 1, and 3. At node 0 the
distance to the splitting plane was 2, meaning the splitting plane is
in front and the not traversed child should be pushed to the
short-stack. At node 1 the distance was 3, so the ray intersects node
1's splitting plane after node 0's. Node 1's other child therefore
doesn't need to be pushed to the stack. The result of the first
traversal can be seen on \reffig{fig:shortStack1}.

So far the short-stack traversal and kd-restart traversal have both
choosen the exact same path through the tree. But kd-restart would
have had to restart from the root node, the short-stack allows the ray
to start the second traversal from node 2 and proceed to leaf 5 where
the ray intersects triangle 2. 

In this simple example having a short-stack only allows the ray to
skip one node at the cost of maintaining and using a short-stack,
which will cause a significant overhead. Consequently in this small
example a short-stack will probably not provide any speedup. But
imagine this simple tree as a subtree in a much larger scene, perhaps
with 10 levels of nodes above it, then a short-stack implementation
allows the ray to skip those first 11 nodes, which can yield quite a
performance improvement.

\begin{figure}
  \centering

  \subfloat[The short stack algorithm's first traversal of the scene
    from \reffig{fig:simpleSceneTree}. When the ray traversed node 0
    it pushed  node 2 onto the short-stack.]{
    \begin{tikzpicture}[y=0.5cm, x=.5cm,font=\sffamily,
        level/.style={sibling distance=40mm/#1}]
      \node [visitedNode] (0){$\begin{array}{c}0\\x:4\end{array}$}
        child {node [visitedNode] (1) {$\begin{array}{c}1\\y:4\end{array}$}
          child {node [visitedLeaf] (e) {$\begin{array}{c}3\\\emptyset\end{array}$}}
          child {node [node] (3) {$\begin{array}{c}4\\x:2\end{array}$}            
            child {node [leaf] (e) {$\begin{array}{c}7\\\{0\}\end{array}$}}
            child {node [leaf] (e) {$\begin{array}{c}8\\\{1\}\end{array}$}}
          }
        }
        child {node [node] (2) {$\begin{array}{c}2\\y:2\end{array}$}
            child {node [leaf] (e) {$\begin{array}{c}5\\\{2\}\end{array}$}}
            child {node [leaf] (e) {$\begin{array}{c}6\\\{3\}\end{array}$}}
        };
                        
      % Short stack
      \draw (10,-4.5) -- (10,-7.5) -- (12,-7.5) -- (12,-4.5) -- (10,-4.5);
      \draw (10, -6.5) -- (12, -6.5);
      \draw (10, -5.5) -- (12, -5.5);
      \draw (11, -7) node{2};
      \draw (11, -6) node{-};
      \draw (11, -5) node{-};
    \end{tikzpicture}
    \label{fig:shortStack1}
  }
  \\
  \subfloat[The short stack algorithm's second traversal of the scene
    from \reffig{fig:simpleSceneTree}. Traversal starts from the first
    node on the stack, which is 2.]{
    \begin{tikzpicture}[y=0.5cm, x=.5cm,font=\sffamily,
        level/.style={sibling distance=40mm/#1}]
      \node [node] (0){$\begin{array}{c}0\\x:4\end{array}$}
        child {node [node] (1) {$\begin{array}{c}1\\y:4\end{array}$}
          child {node [leaf] (e) {$\begin{array}{c}3\\\emptyset\end{array}$}}
          child {node [node] (3) {$\begin{array}{c}4\\x:2\end{array}$}            
            child {node [leaf] (e) {$\begin{array}{c}7\\\{0\}\end{array}$}}
            child {node [leaf] (e) {$\begin{array}{c}8\\\{1\}\end{array}$}}
          }
        }
        child {node [visitedNode] (2) {$\begin{array}{c}2\\y:2\end{array}$}
            child {node [visitedLeaf] (e) {$\begin{array}{c}5\\\{2\}\end{array}$}}
            child {node [leaf] (e) {$\begin{array}{c}6\\\{3\}\end{array}$}}
        };
                        
      % Short stack
      \draw (10,-4.5) -- (10,-7.5) -- (12,-7.5) -- (12,-4.5) -- (10,-4.5);
      \draw (10, -6.5) -- (12, -6.5);
      \draw (10, -5.5) -- (12, -5.5);
      \draw (11, -7) node{-};
      \draw (11, -6) node{-};
      \draw (11, -5) node{-};
    \end{tikzpicture}
    \label{fig:shortStack2}
  }
  \caption{}
\end{figure}


\subsection{Packets}

% Packets: 2x2 packets on the CPU for to take advantage of SIMD
% instructions (Wald), warp size packets on the GPU. While
% \citebook{1230129} implemented packets, they merely assumed it would
% yield a speedup and did not provide any results. Aila2009 is against
% packets as they in practice seem to make it slower.

% As ray tracing becomes more complex packets also become less
% effective, as rays will become more chaotic in nature and less
% likely to fit into packets.

% I will adobt a pretty cheap packet strategy: I will trace my rays in
% 4x8 packets to increase spatial ray coherence across warps.

\subsection{Skipping Leaf Nodes}

% Inspired by empty space splitting.

% Combines BVH and KD tree

% Is not a generel kd-tree optimization. Only works because we already
% have the bounding boxes from the tree creation phase and won't
% deallocate the space.

%% \subsection{Push Down}

%% I will not be implementing the push-down approach from
%% \citebook{1230129}. While it will most likely improve the generel ray
%% tracing case, where some of the geometry will be located behind the
%% rays and can safely be excluded, it will only add an overhead to worst
%% case situations, where the uppermost splitting plane is intersected by
%% the rays.

%% \subsection{Ropes}

%% % stackless raytracing using ropes. 
%% % Place in future works?

%% \subsection{Persistent Threads}

%% % Use persistent threads / own scheduler. Aila2009.

%% \subsection{Caching 'hot' nodes}

%% % wrap node and geometry arrays in textures to utilize cache? Or
%% % simply don't care and refere to cached global memory in future
%% % GPU's?

%% % Like persistent threads, this is not an important optimazition
%% % longterm, since global memory are being given a cache.



\section{Shading}

% Everything is paper thin and empty space
