% Ray tracing structures on the GPU has been mapped more or less 100%
% from CPU structures. We need to build them for the GPU instead. That
% means rethinking some of the algorithms (like add persistent
% threads.)



\chapter{Ray Tracing}\label{chp:rayTracing}

\chapterquote{Some argue that in the very long term, rendering may
  best be solved by some variant of ray tracing, in which huge numbers
  of rays sample the environment for the eye’s view of each frame. And
  there will also be colonies on Mars, underwater cities, and personal
  jet packs.}{Tomas Möller and Eric Haines}

% Motivate!

% An optimized ray tracer will be used to test wether or not more time
% spend on creating a better kD tree will pay off in final rendering
% time.

In this chapter we will look at the actual ray tracing and how to
implement it efficiently on the graphics hardware. The result of this
chapter is an optimized ray tracer, that will be used to test the
quality of the kd-tree and wether or not more time spend on creating a
better kD tree will pay off in final rendering time. The chapter is
divided into 4 parts.

Before we discuss the different approaches to ray tracing, we will
first investigate 2 different ray/triangle intersection algorithms and
discuss them with respect to the graphics cards memory hierarchy and
maximizing occupancy.

We will then motivate the use of acceleration structures on the GPU,
by comparing them to an exhaustive ray tracer, where each ray is
tested against all triangles.

Next I present the hierarchical ray tracer and cover how it traverses
the kd-tree created in the previous section. Optimizations will be
added incrementally to the ray tracer and implementation details to
each specific optimization will therefore be discussed alongside the
theory. The optimized ray tracer will use techniques from
\citebook{Aila2009} and \citebook{1230129} along with an optimization
inspired by empty space splitting.

Finally I will briefly discuss shading and how reflection and
refraction is calculated.

\section{Ray/Triangle Intersection}

The inherent diverging behaviour of each ray makes them hard to
parallize efficiently on the graphics card, since data access will be
nearly impossible to coallesce. The solution is to have enough active
rays to effectively hide data fetching latency. This means that each
rays register usage must be kept to a minimum.

Deciding which ray/triangle intersection method to use when ray
tracing can both lower register usage and give a significant
performance boost.

% Consists of 2 parts. Ray/plane intersection which tells us the
% distance the ray will travel, and ray/triangle tests which tells us
% if the ray intersected the triangle.

Ray/triangle intersection can be broken down into 2 parts: A
\textit{ray/plane intersection} test, which computes the signed
distance a ray will have to travel to intersect the plane spanned by a
triangle, and a \textit{triangle inclusion} test, which tells us if
the intersection point was located inside the triangle. The
intersection inclussion test is usually performed by calculating the
intersection points \textit{barycentric coordinates} within the
triangle.

Every point on a triangle, $T$, with vertices $a$, $b$ and $c$ can be
described as 


\begin{displaymath}
  T(u,v) = (1-u-v)a + ub + vc
\end{displaymath}
 
where $(u, v)$ are the barycentric coordinates. For a barycentric
coordinate to be inside $T$ it must fulfill $0 \le u$, $0 \le v$ and
$u+v \le 1$.

Barycentric coordinates are also important for linearly interpolating
vertex attributes, such as normals or colors, across a triangles
surface.




% Explain barycentric coordinates and how they are important for
% triangle/ray intersection and linearly interpolating the triangle
% attributes at the vertices, such as the normals, colors or texture
% coordiantes. Convex combination?

% Use the barycentric coordinates to perform the intersection test.

\subsection{Möller-Trumbore}

% One of the most popular intersection algorithms and featured in
% Real-Time Rendering.

The Möller-Trumbore algorithm presented in \citebook{MollerTrumbore97}
is one of the most popular algorithms for ray/triangle intersection,
due probably in no small part to it's appearence in chapter 16.8 in
\citebook{RTR3}, but also because it is one of the fastest
ray/triangle intersection algorithms that does not rely on extra
memory and/or precomputation.

% Computes both distance and barycentric coords

% Calculates the transformation that transform the triangle into the
% unit triangle and applies this transformation to the ray.

The basic idea of their algorithm is to find the affine transformation
that when applied to the triangle, $T(u,v)$, given by

\begin{displaymath}
  T(u,v) = (1-u-v)a + ub + vc
\end{displaymath}

transforms it into the unit triangle, $U$, which has vertices
$\vecthreeT{0}{0}{0}$, $\vecthreeT{1}{0}{0}$ and
$\vecthreeT{0}{1}{0}$. That affine transformation is then instead
applied to the ray, $R(t) = O + tD$, which yields the vector
$\vecthreeT{t}{u}{v}$, where $t$ is the distance to the plane spanned
by $T(u,v)$ and $u$ and $v$ are the barycentric coordinates of the
intersection point.

In short this boils down to solving the linear system of equations

\begin{displaymath}
  \begin{array}{rl}
    & R(t) = T(u,v) \\
    \Updownarrow \\
    & O + tD = (1-u-v)a + ub + vc \\
  \end{array}
\end{displaymath}

As can be seen in \citebook{MollerTrumbore97}, by rearranging the
terms and applying Cramer's Rule, the solution is

\begin{displaymath}
  \vecthree{t}{u}{v} = \frac{1}{P \cdot E_1} 
  \vecthree{Q \cdot E_2}{P \cdot T}{Q \cdot D}
\end{displaymath}

where $E_1 = b - a$, $E_2 = c - a$, $T = O - a$, $P = D \times  E_2$
and $Q = T \times  E_1$.

\subsubsection{Implementation}

% Due to the GPU's SIMT architecture, providing as many early out
% possiblities as Möller-Trumbore's implementation caused a branching
% overhead. The universal sweetspot in all of this thesis ray tracers
% was found to be ...

\subsection{Woop}

% Also translates the ray using the unit triangle.

As was the case with the Möller-Trumbore approach, Woops was also
interested in transforming the generel ray/triangle intersection
problem into a ray/unit triangle intersection problem, where the
solution is trivially calculated.

He observed that the triangle, $T$, can be transformed into the unit
triangle, $U$, via an affine transformation, consiting of a rotation
matrix, $m$, and a translation, $n$.

\begin{displaymath}
  U_d = m T_d + n, d \in \{x, y, z\}
\end{displaymath}

% Does some precalculation, which means we can save calculations and
% register space when performaing the actual ray tracing.

% The extra space used by the precalcultations can be mitigated if
% the vertices are no longer needed.

\subsubsection{Implementation}

% Higher occupancy, which in turn will make it easier for the GPU to
% hide global memory lookup latency. Or not. Still at 32 registers.




\section{Exhaustive Ray Tracing}

% GPU does bruteforcing well.

% Cite paper on kNN done on the GPU.

% Algorithm

% Why even use datastructures on the GPU. They work wonders on the CPU
% but for the GPU they might hinder performance (cite KNN paper and
% dataparallism example with 31 threads waiting)


\section{Hierarchical Ray Tracing}

% Brief introduction to several acceleration techniques. BVH, KD,
% quad/oct trees and BSP.

% KD-trees are ze leetzors according to Havran? Another motivation is
% Zhou's paper on fast KD tree construction.

\subsection{KD-restart}

% KD restart is the simplest and fastest.

% Start with kd restart, simple to get up and running.

\begin{algorithm}
  \caption{KD Restart}
  \label{alg:KDRestart}
  \begin{algorithmic}
    \PROCEDURE{KDRestart}
              {$ray$ : Ray}
              {$t_{min}$ : Integer}{
                \ASSIGN{$t_{min}$}{$0$}
                \WHILE{$t_{min} < \infty$}
                  \ASSIGN{$t_{next}$}{$\infty$}
                  \ASSIGN{$node$}{$root$}
                  \COMMENTIT{Traverse the tree until a leaf node is reached}
                  \WHILE{$node.info \neq LEAF$}
                    \ASSIGN{$t_{split}$}{($node.splitValue - ray.origin[node.axis]) / ray.direction[node.axis]$}
                    \IF{$t_{min} < t_{split}$}
                      \ASSIGN{$node$}{$ray.direction[node.axis] > 0$ ? $node.left$ : $node.right$}
                      \ASSIGN{$t_{next}$}{min$(t_{split}, t_{next})$}
                    \ELSE
                      \ASSIGN{$node$}{$ray.direction[node.axis] > 0$ ? $node.right$ : $node.left$}
                    \ENDIF
                  \ENDWHILE
                  \COMMENTIT{Advance the ray to the next splitting plane.}
                  \ASSIGN{$t_{min}$}{$t_{next}$}
                  \COMMENTIT{Test intersection with the leafs primitives}
                  \FOREACH{$triangle$}{$node.triangles$}
                    \ASSIGN{$t_{min}$}{\MIN{$(t_{min}}{$\textbf{Intersect}$(triangle, ray))$}}
                  \ENDFOR
                \ENDWHILE
                \STATE{\bf{return} $t_{min}$}
              }
  \end{algorithmic}
\end{algorithm}

\subsection{Packets}

% Packets: 2x2 packets on the CPU for to take advantage of SIMD
% instructions (Wald), warp size packets on the GPU. While
% \citebook{1230129} implemented packets, they merely assumed it would
% yield a speedup and did not provide any results. Aila2009 is against
% packets as they in practice seem to make it slower.

% As ray tracing becomes more complex packets also become less
% effective, as rays will become more chaotic in nature and less
% likely to fit into packets.

% I will adobt a pretty cheap packet strategy: I will trace my rays in
% 4x8 packets to increase ray coherence across warps.

\subsection{Short stack}

% Only push usefull 'forward' nodes to the stack.

\begin{algorithm}
  \caption{Short stack}
  \label{alg:ShortStack}
  \begin{algorithmic}
    \PROCEDURE{ShortStack}
              {$ray$ : Ray}
              {$t_{min}$ : Integer}{
    \ASSIGN{$t_{min}$}{$0$}
    \WHILE{$t_{min} < \infty$}
      \IF{$\color{green}stack.IsEmpty$}
        \ASSIGN{$node$}{$root$}
        \ASSIGN{$t_{next}$}{$\infty$}
      \ELSE
        \color{green}\ASSIGN{$(node, t_{next})$}{stack.pop}
      \ENDIF
      \COMMENTIT{Traverse the tree until a leaf node is reached}
      \WHILE{$node.info \neq LEAF$}
        \ASSIGN{$t_{split}$}{($node.splitValue - ray.origin[node.axis]) / ray.direction[node.axis]$}
        \IF{$t_{min} < t_{split}$}
          \ASSIGN{$node$}{$ray.direction[node.axis] > 0$ ? $node.left$ : $node.right$}
          \IF{$\color{green}t_{split} < t_{next}$}
            \color{green}\STATE{stack.push($upperChild, t_{next}$)}
          \ENDIF
          \ASSIGN{$t_{next}$}{min$(t_{split}, t_{next})$}
        \ELSE
          \ASSIGN{$node$}{$ray.direction[node.axis] > 0$ ? $node.right$ : $node.left$}
        \ENDIF
      \ENDWHILE
      \COMMENTIT{Advance the ray to the next splitting plane.}
      \ASSIGN{$t_{min}$}{$t_{next}$}
      \COMMENTIT{Test intersection with the leafs primitives}
      \FOREACH{$triangle$}{$node.triangles$}
        \ASSIGN{$t_{min}$}{min$(t_{min}, $\bf{Intersect}$(triangle, ray))$}
      \ENDFOR
    \ENDWHILE
    \STATE{\bf{return} $t_{min}$}
              }
  \end{algorithmic}
\end{algorithm}

\subsection{Skipping Leaf Nodes}

% Inspired by empty space splitting.

% Combines BVH and KD tree

\subsection{Push Down}

I will not be implementing the push-down approach from
\citebook{1230129}. While it will most likely improve the generel ray
tracing case, where some of the geometry will be located behind the
rays and can safely be excluded, it will only add an overhead to worst
case situations, where the uppermost splitting plane is intersected by
the rays.

\subsection{Ropes}

% stackless raytracing using ropes. 
% Place in future works?

\subsection{Persistent Threads}

% Use persistent threads / own scheduler. Aila2009.

\subsection{Caching 'hot' nodes}

% wrap node and geometry arrays in textures to utilize cache? Or
% simply don't care and refere to cached global memory in future
% GPU's?

% Like persistent threads, this is not an important optimazition
% longterm, since global memory are being given a cache.



\section{Coloring}

% Everything is paper thin and empty space
