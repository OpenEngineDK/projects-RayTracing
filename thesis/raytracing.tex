\chapter{Ray Tracing}

\chapterquote{Some argue that in the very long term, rendering may
  best be solved by some variant of ray tracing, in which huge numbers
  of rays sample the environment for the eye’s view of each frame. And
  there will also be colonies on Mars, underwater cities, and personal
  jet packs.}{Tomas Möller and Eric Haines}

% Motivate!

% We will build a basic raytracer to test the quality of the kD tree.

% An optimized raytracer will be used to test wether or not more time
% spend on creating a better kD tree will pay off in final rendering
% time.

The optimized raytracer will use techniques from \citebook{Aila2009}
and \citebook{1230129}.

% Generel ray tracing code.

% Ray triangle intersection, refer to Wald's thesis. Something
% something about projecting triangles onto planes and doing a lot of
% precalculation. Should be faster than Möller-Trumbore's method. Lets
% test it :) Or not :p

\section{Triangle Intersection}

% Consists of 2 parts. Ray/plane intersection which tells us the
% distance the ray will travel, and ray/triangle tests which tells us
% if the ray intersected the triangle.

% Explain barycentric coordinates and how they are important for
% triangle/ray intersection and linearly interpolating the triangle
% attributes at the vertices.

\subsection{Möller-Trumbore}

% One of the most popular intersection algorithms and featured in
% Real-Time Rendering.

% Computes both distance and barycentric coords

% Calculates the transformation that transform the triangle into the
% unit triangle and applies this transformation to the ray.

% Uses the barycentric coordinates to perform the intersection test.

\subsection{Woop}

% Also translates the ray using the unit triangle.

% Does some precalculation, which means we can save calculations and
% register space when performaing the actual ray tracing.

% Higher occupancy, which in turn will make it easier for the GPU to
% hide global memory lookup latency.

\section{Acceleration Techniques}

% Brief introduction to several acceleration techniques

% KD restart is the simplest

\subsection{Push Down}

I will not be implementing the push-down approach from
\citebook{1230129}. While it will most likely improve the generel ray
tracing case, where some of the geometry will be located behind the
rays and can safely be excluded, it will only add an overhead to worst
case situations, where the uppermost splitting plane is intersected by
the rays.

\subsection{Packets}

% Packets: 2x2 packets on the CPU for to take advantage of SIMD
% instructions (Wald), warp size packets on the GPU. While
% \citebook{1230129} implemented packets, they merely assumed it would
% yield a speedup and did not provide any results. Aila2009 is against
% packets as they in practice seem to make it slower.

% As ray tracing becomes more complex packets also become less
% effective, as rays will become more chaotic in nature and less
% likely to fit into packets.

% I will adobt a pretty cheap packet strategy: I will trace my rays in
% 4x8 packets to increase ray coherence across warps.

\subsection{Short stack}

% Only push usefull 'forward' nodes to the stack.

\subsection{Ropes}

% stackless raytracing using ropes. 

\subsection{Persistent Threads}

% Use persistent threads / own scheduler. Aila2009.

\subsection{Caching 'hot' nodes}

% wrap node and geometry arrays in textures to utilize cache? Or
% simply don't care and refere to cached global memory in future
% GPU's?

\section{Implementation}

\subsection{KD-restart}

% Start with kd restart, simple to get up and running.

\begin{algorithm}
  \caption{KD Restart}
  \label{alg:KDRestart}
  \begin{algorithmic}
    \PROCEDURE{KDRestart}
              {$ray$ : Ray}
              {$t_{min}$ : Integer}{
                \ASSIGN{$t_{min}$}{$0$}
                \WHILE{$t_{min} < \infty$}
                  \ASSIGN{$t_{next}$}{$\infty$}
                  \ASSIGN{$node$}{$root$}
                  \COMMENTIT{Traverse the tree until a leaf node is reached}
                  \WHILE{$node.info \neq LEAF$}
                    \ASSIGN{$t_{split}$}{($node.splitValue - ray.origin[node.axis]) / ray.direction[node.axis]$}
                    \ASSIGN{$lowerChild$}{$ray.direction[node.axis] > 0$ ? $node.left$ : $node.right$}
                    \ASSIGN{$upperChild$}{$ray.direction[node.axis] > 0$ ? $node.right$ : $node.left$}
                    \IF{$t_{min} < t_{split}$}
                      \ASSIGN{$node$}{$lowerChild$}
                      \ASSIGN{$t_{next}$}{min$(t_{split}, t_{next})$}
                    \ELSE
                      \ASSIGN{$node$}{$upperChild$}
                    \ENDIF
                  \ENDWHILE
                  \COMMENTIT{Advance the ray to the next splitting plane.}
                  \ASSIGN{$t_{min}$}{$t_{next}$}
                  \COMMENTIT{Test intersection with the leafs primitives}
                  \FOREACH{$triangle$}{$node.triangles$}
                    \ASSIGN{$t_{min}$}{min$(t_{min}, $\bf{Intersect}$(triangle, ray))$}
                  \ENDFOR
                \ENDWHILE
                \STATE{\bf{return} $t_{min}$}
              }
  \end{algorithmic}
\end{algorithm}

\subsection{Short stack}

\begin{algorithm}
  \caption{Short stack}
  \label{alg:ShortStack}
  \begin{algorithmic}
    \PROCEDURE{ShortStack}
              {$ray$ : Ray}
              {$t_{min}$ : Integer}{
    \ASSIGN{$t_{min}$}{$0$}
    \WHILE{$t_{min} < \infty$}
      \IF{$\color{green}stack.IsEmpty$}
        \ASSIGN{$node$}{$root$}
        \ASSIGN{$t_{next}$}{$\infty$}
      \ELSE
        \color{green}\ASSIGN{$(node, t_{next})$}{stack.pop}
      \ENDIF
      \COMMENTIT{Traverse the tree until a leaf node is reached}
      \WHILE{$node.info \neq LEAF$}
        \ASSIGN{$t_{split}$}{($node.splitValue - ray.origin[node.axis]) / ray.direction[node.axis]$}
        \ASSIGN{$lowerChild$}{$ray.direction[node.axis] > 0$ ? $node.left$ : $node.right$}
        \ASSIGN{$upperChild$}{$ray.direction[node.axis] > 0$ ? $node.right$ : $node.left$}
        \IF{$t_{min} < t_{split}$}
          \ASSIGN{$node$}{$lowerChild$}
          \IF{$\color{green}t_{split} < t_{next}$}
            \color{green}\STATE{stack.push($upperChild, t_{next}$)}
          \ENDIF
          \ASSIGN{$t_{next}$}{min$(t_{split}, t_{next})$}
        \ELSE
          \ASSIGN{$node$}{$upperChild$}
        \ENDIF
      \ENDWHILE
      \COMMENTIT{Advance the ray to the next splitting plane.}
      \ASSIGN{$t_{min}$}{$t_{next}$}
      \COMMENTIT{Test intersection with the leafs primitives}
      \FOREACH{$triangle$}{$node.triangles$}
        \ASSIGN{$t_{min}$}{min$(t_{min}, $\bf{Intersect}$(triangle, ray))$}
      \ENDFOR
    \ENDWHILE
    \STATE{\bf{return} $t_{min}$}
              }
  \end{algorithmic}
\end{algorithm}


\subsection{Persistent Threads}

\section{Coloring}

% Everything is paper thing and empty space
