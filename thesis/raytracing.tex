\chapter{Ray Tracing}

\chapterquote{Some argue that in the very long term, rendering may
  best be solved by some variant of ray tracing, in which huge numbers
  of rays sample the environment for the eye’s view of each frame. And
  there will also be colonies on Mars, underwater cities, and personal
  jet packs.}{Tomas Möller and Eric Haines}

% Motivate!

% We will build a basic raytracer to test the quality of the kD tree.

% An optimized raytracer will be used to test wether or not more time
% spend on creating a better kD tree will pay off in final rendering
% time.

The optimized raytracer will use techniques from \citebook{Aila2009}
and \citebook{1230129}.

% Generel ray tracing code.

% Ray triangle intersection, refer to Wald's thesis. Something
% something about projecting triangles onto planes and doing a lot of
% precalculation. Should be faster than Möller-Trumbore's method. Lets
% test it :) Or not :p

\section{Acceleration Techniques}

% Brief introduction to several acceleration techniques

% KD restart is the simplest

\subsection{Push Down}

I will not be implementing the push-down approach from
\citebook{1230129}. While it will most likely improve the generel ray
tracing case, where some of the geometry will be located behind the
rays and can safely be excluded, it will only add an overhead to worst
case situations, where the uppermost splitting plane is intersected by
the rays.

\subsection{Packets}

% Packets: 2x2 packets on the CPU for to take advantage of SIMD
% instructions (Wald), warp size packets on the GPU. While
% \citebook{1230129} implemented packets, they merely assumed it would
% yield a speedup and did not provide any results. Aila2009 is against
% packets as they in practice seem to make it slower.

\subsection{Short stack}

% Only push usefull 'forward' nodes to the stack.

\subsection{Ropes}

% stackless raytracing using ropes. 

\subsection{Persistent Threads}

% Use persistent threads / own scheduler. Aila2009.

\subsection{Caching 'hot' nodes}

% wrap node and geometry arrays in textures to utilize cache? Or
% simply don't care and refere to cached global memory in future
% GPU's?

\section{Implementation}

\subsection{KD-restart}

% Start with kd restart, simple to get up and running.

\begin{algorithm}
  \caption{KD Restart}
  \label{alg:KDRestart}
  \begin{algorithmic}
    \PROCEDURE{KDRestart}
              {$ray$ : Ray}
              {$t_{min}$ : Integer}{
                \ASSIGN{$t_{min}$}{$0$}
                \WHILE{$t_{min} < \infty$}
                  \ASSIGN{$t_{next}$}{$\infty$}
                  \ASSIGN{$node$}{$root$}
                  \COMMENTIT{Traverse the tree until a leaf node is reached}
                  \WHILE{$node.info \neq LEAF$}
                    \ASSIGN{$t_{split}$}{($node.splitValue - ray.origin[node.axis]) / ray.direction[node.axis]$}
                    \ASSIGN{$lowerChild$}{$ray.direction[node.axis] > 0$ ? $node.left$ : $node.right$}
                    \ASSIGN{$upperChild$}{$ray.direction[node.axis] > 0$ ? $node.right$ : $node.left$}
                    \IF{$t_{min} < t_{split}$}
                      \ASSIGN{$node$}{$lowerChild$}
                      \ASSIGN{$t_{next}$}{min$(t_{split}, t_{next})$}
                    \ELSE
                      \ASSIGN{$node$}{$upperChild$}
                    \ENDIF
                  \ENDWHILE
                  \COMMENTIT{Advance the ray to the next splitting plane.}
                  \ASSIGN{$t_{min}$}{$t_{next}$}
                  \COMMENTIT{Test intersection with the leafs primitives}
                  \FOREACH{$triangle$}{$node.triangles$}
                    \ASSIGN{$t_{min}$}{min$(t_{min}, $\bf{Intersect}$(triangle, ray))$}
                  \ENDFOR
                \ENDWHILE
                \STATE{\bf{return} $t_{min}$}
              }
  \end{algorithmic}
\end{algorithm}

\subsection{Short stack}

\begin{algorithm}
  \caption{Short stack}
  \label{alg:ShortStack}
  \begin{algorithmic}
    \PROCEDURE{ShortStack}
              {$ray$ : Ray}
              {$t_{min}$ : Integer}{
    \ASSIGN{$t_{min}$}{$0$}
    \WHILE{$t_{min} < \infty$}
      \IF{$\color{green}stack.IsEmpty$}
        \ASSIGN{$node$}{$root$}
        \ASSIGN{$t_{next}$}{$\infty$}
      \ELSE
        \color{green}\ASSIGN{$(node, t_{next})$}{stack.pop}
      \ENDIF
      \COMMENTIT{Traverse the tree until a leaf node is reached}
      \WHILE{$node.info \neq LEAF$}
        \ASSIGN{$t_{split}$}{($node.splitValue - ray.origin[node.axis]) / ray.direction[node.axis]$}
        \ASSIGN{$lowerChild$}{$ray.direction[node.axis] > 0$ ? $node.left$ : $node.right$}
        \ASSIGN{$upperChild$}{$ray.direction[node.axis] > 0$ ? $node.right$ : $node.left$}
        \IF{$t_{min} < t_{split}$}
          \ASSIGN{$node$}{$lowerChild$}
          \IF{$\color{green}t_{split} < t_{next}$}
            \color{green}\STATE{stack.push($upperChild, t_{next}$)}
          \ENDIF
          \ASSIGN{$t_{next}$}{min$(t_{split}, t_{next})$}
        \ELSE
          \ASSIGN{$node$}{$upperChild$}
        \ENDIF
      \ENDWHILE
      \COMMENTIT{Advance the ray to the next splitting plane.}
      \ASSIGN{$t_{min}$}{$t_{next}$}
      \COMMENTIT{Test intersection with the leafs primitives}
      \FOREACH{$triangle$}{$node.triangles$}
        \ASSIGN{$t_{min}$}{min$(t_{min}, $\bf{Intersect}$(triangle, ray))$}
      \ENDFOR
    \ENDWHILE
    \STATE{\bf{return} $t_{min}$}
              }
  \end{algorithmic}
\end{algorithm}


\subsection{Persistent Threads}

\section{Coloring}

% Everything is paper thing and empty space
