\chapter{Ray Tracing}


% Motivate!

% We will build a basic raytracer to test the quality of the kD tree.

% An optimized raytracer will be used to test wether or not more time
% spend on creating a better kD tree will pay off in final rendering
% time.

The optimized raytracer will use techniques from \citebook{Aila2009}
and \citebook{1230129}.

% Generel ray tracing code.

% Ray triangle intersection, refer to Wald's thesis. Something
% something about projecting triangles onto planes and doing a lot of
% precalculation. Should be faster than MÃ¶ller-Trumbore's method. Lets
% test it :) Or not :p

\section{Acceleration Techniques}

% KD restart is the simplest

I will not be implementing the push-down approach from
\citebook{1230129}. While it will most likely improve the generel ray
tracing case, where some of the geometry will be located behind the
rays and can safely be excluded, it will only add an overhead to worst
case situations, where the uppermost splitting plane is intersected by
the rays.

% Packets: 2x2 packets on the CPU for to take advantage of SIMD
% instructions (Wald), warp size packets on the GPU. While
% \citebook{1230129} implemented packets, they merely assumed it would
% yield a speedup and did not provide any results. Aila2009 is against
% packets as they in practice seem to make it slower.

% short stacks: Implement stacks or perhaps a link to the parent in
% each node. Would save us the hazzle of updating the stacks, which
% could be a waste of time.

% Use persistent threads / own scheduler. Aila2009.

% stackless raytracing using ropes. 

% wrap node and geometry arrays in textures to utilize cache? Or
% simply don't care and refere to cached global memory in future
% GPU's?

\section{Implementation}

% Start with kd restart, simple to get up and running.

\begin{algorithm}
  \caption{KD Restart}
  \label{alg:KDRestart}
  \begin{algorithmic}
    \ASSIGN{t_{min}}{0}
    %\ASSIGN{t_{next}}{\infty}
    \WHILE{$t_{min} \neq \infty$}
      \ASSIGN{t_{next}}{\infty}
      \ASSIGN{node}{root}
      \COMMENTIT{Traverse the tree until a leaf node is reached}
      \WHILE{$node.info \neq LEAF$}
        \ASSIGN{k}{node.axis}
        \COMMENTIT{@TODO: How to handle division by zero?}
        \ASSIGN{t_{split}}{(node.splitValue - ray.origin[k]) / ray.direction[k]}
        \ASSIGN{lowerChild}{ray.direction[k] > 0$ ? $node.left$ : $node.right}
        \ASSIGN{upperChild}{ray.direction[k] > 0$ ? $node.right$ : $node.left}
        \IF{$t_{min} < t_{split}$}
          \ASSIGN{node}{lowerChild}
          \ASSIGN{t_{next}}{min(t_{split}, t_{next})}
        \ELSE
          \ASSIGN{node}{upperChild}
        \ENDIF
      \ENDWHILE
      \COMMENTIT{@TODO: Perhaps tSplit can be used instead, with a check for if tSplit < tMin then no go}
      \ASSIGN{t_{min}}{t_{next}}
      \COMMENTIT{Test intersection with the leafs primitives}
    \ENDWHILE
  \end{algorithmic}
\end{algorithm}

% Implement short stack and persistent threads.


