%% • The introduction must be dynamite. 
%% – The reader forms an oppinion of the work right from the start... 
%% • The introduction is an extension of the abstract. 
%% • Should be easy to read and understand 
%% • Should make it easy for anyone to tell
%% – What your paper is about 
%%   – What problem it solves
%%   – Why the problem and solution is interesting and relevant (motivation and context). Is it a long- outstanding problem?
%%   – What is new in your paper and how (much) does it improve on the strongest alternatives/previous work (include a few of the most relevant references here).

%% • Start the introduction with the motivation. Think in large contexts and don’t be afraid to be a poet.
%% • All implications, contributions and keypoints of your work must be included here.
%% • Make it very clear how your work will impact the future of Realistic image generation (will people use it?).
%% • If your work is pioneering, s-p-e-l-l i-t o-u-t.
%% • Briefly make it clear how you evaluate your method in the Results section.
%% • Make sure to explain where your method applies and where it does not apply (limitations).


\chapter{Introduction}

\chapterquote{Focus is a matter of deciding what things you're not
  going to do.}{John Carmack}

Rendering is the process of converting a description of a scene into
an image and lies at the heart of computer graphics. 

% Why global illumination vs local illumination used in most
% rasterizers. Ray tracing can produce more correct images, and it
% scales $O(N log M)$, whereas rasterizers scale O(NM).

Several techniques exist that allows computers to perform this
conversion. When real-time rendering is needed, the most commonly used
technique is \textit{rasterization}, in which vertex attrbiutes of
geometric shapes are mapped onto a raster\footnote{A flat, 2D grid.}
and subsequently \textit{shaded}. Due to the popularity of this
technique in computer games, hardware accelerated rasterizers have
become quite powerful over the last decade and are now able to process
millions of geometric primitives pr. second. However, certain aspects
of rendering are not easily solved by rasterization.
\textit{Reflection} and \textit{refraction} effects on non-flat
surfaces are notoriously hard to recreate, due to the divergence of
individual light rays at these points, and must instead be
approximated. Reflection by an object is usually approximated by
\textit{environment mapping}, as can be seen on
\reffig{fig:cubemap}. The problem with this approch is that the scene
will have to be rendered an additional 6 times for each frame.

\begin{figure}
  \centering
  \includegraphics{Cube_mapped_reflection_example}
  \caption{An example of environment mapping. The environment is
    rendered to the sides of the cube and then mapped onto the sphere.
    The mapping is performed by using the calculated reflection vector
    as texture coordinates.}
%TODO image curtesy of http://en.wikipedia.org/wiki/Reflection_mapping
  \label{fig:cubemap}
\end{figure}

An alternative to rasterization is presented by \textit{ray casting}
or \textit{ray tracing}. In ray tracing, each individual pixel is
shaded by tracing one or more \textit{primary rays} ``cast'' from the
camera into the world and observing which primitive they
intersect. Reflection and refraction are easily created by spawning a
new ray at the intersection point and then tracing it. In contrast to
rasterization this provides a much more correct result, easily allows
for multiple \textit{reflection rays} and as we shall see in section
TODO at a much better lower cost increase pr. frame. Shadows are also
easily created using ray tracing. Hard edged shadows can be created by
tracing a \textit{shadow ray} from an intersection point towards a
lightsource. If the shadow ray intersects another part of the world
before it reaches the lightsource, then the intersection point must be
placed in shadow and does not receive any illumination from the
lightsource. Using advanced lighting algorithms such as \textit{photon
  mapping}, which incorporates ray tracing for light transportation,
lighting from reflective surfaces, color bleeding and even correct
caustics can be simulated.

% TODO reflection image.

Nevertheless, the photorealistic images rendered by ray tracers does
come at a high computational cost, which is why ray tracing is mostly
used for offline renderers, for example special effects in movies or
high quality images.

% Due to increase on computing power, we're getting closer and closer
% to seeing real time ray tracing and it's lighting in
% applications. Bla bla rewrite!

% The evergrowing interest in photorealistic rendering and the
% complexity of the scenes rendered.

But, due to the everincreasing computational power and continued
research into \textit{global illumination acceleration techniques},
the physically correct image quality obtainable though ray tracing is
becoming more and more alluring to designers of real time graphical
applications, especially if correct reflection or refraction is
needed.


% Why use the GPU? Offloading. The CPU can do a lot of other things
% while the GPU crunch away at those KD trees. Om nom nom nom
% nom.... Games already make heavy use of the CPU for game logics,
% networking and AI, they need to offload graphics to the another
% processing unit.

In this thesis I will be combining the rendering quality of ray
tracing with the computational power of modern
\textit{GPGPU}'s\footnote{General Purpose Graphics Processing
  Units.}. This requires that the algorithms presented exploit the
massively dataparallel nature of the graphics card, requiring
thousands of threads for each GPGPU program. This subject will be
discussed in \refchapter{chp:GPGPU}

There are several good reasons for using GPGPU's for ray tracing. Each
ray can be traced independently and in parallel with all the other
rays. Even at a resolution of 512x512, 262144 primary rays are
generated, resulting in more than enough threads to potentionally
utilize all of the GPGPU's multiprocessors. In the case of computer
games, the CPU is already heavily occupied with \textit{game logic},
\textit{networking}, \textit{AI}\footnote{Artificial Intelligence} and
more to also handle rendering, in which case offloading to an
otherwise idle GPGPU only makes sense. Recent advances in GPGPU ray
tracing have also shown performance comparable to CPU
implementations\citebook{1230129}\citebook{popov:07:GPURT}, meaning
the choice of architecture can now be based purely on where most
performance will be available.

Recent advances in acceleration structure creation have allowed them
to be created equally fast on the CPU and
GPGPU\citebook{1409079}. Therefore, as with ray tracing, this thesis
will focus on a GPGPU implementation, to reduce the workload of the
CPU. Keeping the entire workload on the graphics card has the added
benefit of minimizing datatransfers over the bus.

% In this thesis I present an exhaustive ray tracer and compared it to
% a basic non optimized ray tracer traversing a KD-tree, to emphasize
% the importance of datastructures, even on the GPU.

% importance of efficient datastructures, several datastructures have
% been used for ray tracing (BVH, kd-trees, octrees, bla bla...) Some
% are good for bla, others blank

% 2 ways to optimize ray tracing with respect to dynamic
% scenes. Either optimize the ray tracer or optimize the time it takes
% to build the datastructure. The goal of this thesis is to explorer
% the compromises made in order to efficiently ray trace dynamic
% scenes

% Reference the 'good' kd tree double speed up (don't remember where
% it is) and how it doesn't say anything about the extra time spend on
% these good tree.

\quotebook{With todays's fast ray tracers, the difference between a
  ``good'' and a naïvely built kd-tree is often a factor of 2 or more.}{wald:06:NlogN}

% Needs to exploit the massively parallel architecture of GPGPU's
% which require oh so many thread

% can be done by parallising the evaluation of the approximate cost of
% each node

\textit{Surface Area Heuristic}, $SAH$, 

% and creation of nodes at lower tree levels

% Still not easily paralisable, requires lots of reduction kernels,
% which do not utilize the GPU fully. Also individual node splitting
% costs can leave 31 threads in a warp waiting for the last one to
% finish. 

\subsection{Goals}

In this thesis the goal is not to produce images of photorealistic
quality, or create an interactive ray tracer for dynamic
scenes \footnote{This goal in itself can trivially be achieved by
  reducing the complexity of the scene or lowering the resolution.}

% Ray tracing structures on the GPU has been mapped more or less 100%
% from CPU structures. We need to build them for the GPU instead. That
% means rethinking some of the algorithms (like add persistent
% threads.)

% This thesis will explorer different aspects of KD-tree construction,
% how it affects ray tracing performance and how many resources should
% be devoted to KD-tree construction.

% During this I will look at the usefulness of hierachical traversal
% on the GPU, given that a binary data structure is not easy for the
% GPU to handle and breaks coalescence. An exhaustive force ray
% tracer, that performs intersection with all triangles, will be used
% to motivate the use of a hierachical datatstructure, even on the GPU.

% The thesis will look at alternatives to triangle splitting, namely
% \textit{triangle division}, where the triangle is not split by
% splitting planes, but divided onto each side, by simply adjusting
% it's bounding box, and \textit{box inclusion}, where the triangles
% themselves are not tested for inclusion, but their bounding boxes
% ares.

% The inherent diverging behaviour of each ray makes them hard to
% parallize efficiently, since data access will be nearly impossible
% to coallesce. The solution is to have enough active rays to hide the
% latency, which means each rays register usage must be kept to a
% minimum.

% In this thesis I will build an optimized ray tracer to compare time
% spend ray tracing with time spend building the
% datastructure. Optimizing the ray tracer for this comparison is
% important, since the optimized implementation is up to 80% faster
% than then a basic implementation.

% Optimizations to the ray tracer will be inspired by the work done in
% \citebook{1230129}, but also include the ray/triangle intersection
% algorithm, an improvement inspired by empty space splitting during
% kd-tree creation and simply structuring the rays in a manner that
% favors SIMT execution.



% Result evaluation

% Ray tracing optimizations will simply be evaluated based time saved
% during ray tracing. Optimizations will be based on improving the
% worst case scenarios, ie long rays shooting towards the center of
% the scene.

% Strategies that optimize the KD-tree will be evaluated based on the
% time added to the kd-tree creation phase, and the time saved in the
% ray tracing phase.


\subsection{Overview}
