%% Briefly motivate your work and its context. 

%% Summarize your work/method and the results (it was X times better than the
%% strongest alternative).

%% Spell out the implications for and the impacts on ”ray tracing”. Why it is
%% useful and interesting?

%% Keep in mind that the conclusion will be the last the reviewer reads: You
%% want to leave him with a good impression. - Don’t end the conclusion by
%% saying ”My method can’t do that...” but end by stating its importance and
%% impact.


\chapter{Conclusion}

\chapterquote{The best thing about a boolean is even if you are wrong,
  you are only off by a bit.}{Anonymous}

%\fixme{Conclusion must mirror the goals in chp 1! Do it!}

In this thesis I have presented several different algorithms for constructing
kd-trees and compared their construction speed and their quality, using an
optimized hierarchical ray tracer and applying the kd-tree constructors to
dynamic scenes.

% Conclude on ray tracers

% Exhaustive only usefull in small scenes

In \refchapter{chp:results} I tested an exhaustive ray tracer and compared it
against hierarchical ray tracer solutions. The result was that the exhaustive
ray tracer did not scale nearly as well with scene complexity as the
hierarchical approaches and I can therefore conclude that acceleration
structures should still be used for dynamic scenes.

% Short stack overhead making it only useful in large scenes.

Both packets and leaf skipping proved to be reliable optimizations that only
provided a small overhead in the very simple Cornell Box scene, but otherwise
always sped up ray tracing. The short-stack optimization did not provide such a
stable increase in speed. Even for the fairly complex reflecting dragon scene,
the overhead from maintaining a stack was still too much to provide any
performance boost. However in the Sponza scene, where the tree was twice as
large compared to the dragon scene, adding a short-stack allowed the rays to
avoid re-traversing large parts of the tree and thus improve their overall
performance. I can therefore conclude that while the short-stack optimization may
not always provide a decreased rendering time, using it allows the ray tracer to
perform better in complex scenes.


% Conclude on kd-trees

I have during this thesis presented four different algorithms for splitting the
nodes in a kd-tree and two schemes for associating triangles with the resulting
child nodes.

%% Conclude overall! evaluate the tradeoff between construction speed and tree
%% quality.





%% This section is usually combined with the conclusion section described next.

%% State immediate extensions of your work, things you did not have time to do,
%% or related well-known problems.

%% If you state a future work problem that you don’t want others to steal, say
%% you are already working on it or that it is ”almost” in submission elsewhere.


\chapter{Future Work}\label{chp:future}

\chapterquote{Software is like entropy: It is difficult to grasp,
  weighs nothing, and obeys the Second Law of Thermodynamics; i.e., it
  always increases.}{Norman Augustine}

While I am quite content with the performance of the kd-trees and ray tracers
produced as part of this project, there is still room for optimizations.

% New node layout

First of all the layout of the individual nodes can be optimized. As stated in
\refsection{sec:treeRepresentation} my nodes contain a pointer to each of its
children, which provided me with the flexibility I needed to inject nodes
produced by Empty Space Maximization into the tree. The standard layout of nodes
in a kd-tree is to place sibling nodes next to each other, so they can both be
referenced by one pointer. Compared to the standard layout my kd-tree therefore
takes up four extra bytes per node, which must be loaded each time a ray
traverses a node. It is therefore quite possible that converting my current
kd-tree constructor to work with the standard layout would improve ray tracing
performance, since less data would have to be fetched from global memory per
node visited.


% Optimize triangle divide by excluding uninteresting test cases.

In \reffig{fig:upperResults} we saw that the Dividing triangle/node association
scheme produced kd-trees of superior quality compared with Box
Inclusion. Therefore improving the execution time of the Dividing approach to
produce trees at a speed comparable to Box Inclusion would be worthwile. This
might be done by utilizing the knowledge we have about the splitting axis. When
splitting an interior node by a splitting plane, the resulting childrens
bounding box will consist of five of the same sides as their parent node's
bounding box. This knowledge can be utilized to skip som of the intersection
tests described in \citebook{Moller:2005} and thus decrease construction
time. It would be implemented by a switch with a case for each axis and since
all triangles in a segment belong to the same node, all threads in a warp would
follow the same execution path. Unfortunately my preliminary attempts at
implementing this optimization has been hindered by the compiler, which inlines
the switch to avoid branching and thus creates a large overhead.

% Speed up empty space splitting

Finally I might be able to speed up Empty Space Maximization by caching the
empty space nodes in a list in shared memory and then dumping them that list
coalesced to global memory once every thread in a warp is done creating empty
space node. Since the time spend creating empty space nodes is already relative
low, 4-6ms in the test scenes, this optimization has a very low priority.


% Optimize SAH/SSAH





%% KD/BVH combination trees: still only carry information for one dimension, but
%% also provide near and far planes, useful for estimating the advancement of
%% the ray's $t_{min}$.
